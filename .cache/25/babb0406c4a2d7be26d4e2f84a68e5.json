{"id":"node_modules/@walletconnect/sign-client/dist/index.es.js","dependencies":[{"name":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/sign-client/dist/index.es.js.map","includedInParent":true,"mtime":1721502865724},{"name":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/package.json","includedInParent":true,"mtime":1721990127148},{"name":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/sign-client/package.json","includedInParent":true,"mtime":1721502865724},{"name":"@walletconnect/core","loc":{"line":1,"column":105,"index":105},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/sign-client/dist/index.es.js","resolved":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/core/dist/index.es.js"},{"name":"@walletconnect/logger","loc":{"line":1,"column":228,"index":228},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/sign-client/dist/index.es.js","resolved":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/logger/dist/cjs/index.js"},{"name":"@walletconnect/types","loc":{"line":1,"column":295,"index":295},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/sign-client/dist/index.es.js","resolved":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/types/dist/index.es.js"},{"name":"@walletconnect/utils","loc":{"line":1,"column":1071,"index":1071},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/sign-client/dist/index.es.js","resolved":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/utils/dist/index.es.js"},{"name":"events","loc":{"line":1,"column":1128,"index":1128},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/sign-client/dist/index.es.js","resolved":"/Users/tamaz/.npm-global/lib/node_modules/parcel-bundler/node_modules/events/events.js"},{"name":"@walletconnect/time","loc":{"line":1,"column":1271,"index":1271},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/sign-client/dist/index.es.js","resolved":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/time/dist/cjs/index.js"},{"name":"@walletconnect/jsonrpc-utils","loc":{"line":1,"column":1491,"index":1491},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/sign-client/dist/index.es.js","resolved":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.WALLETCONNECT_DEEPLINK_CHOICE = exports.SignClient = exports.SIGN_CLIENT_VERSION = exports.SIGN_CLIENT_STORAGE_PREFIX = exports.SIGN_CLIENT_STORAGE_OPTIONS = exports.SIGN_CLIENT_PROTOCOL = exports.SIGN_CLIENT_EVENTS = exports.SIGN_CLIENT_DEFAULT = exports.SIGN_CLIENT_CONTEXT = exports.SESSION_REQUEST_EXPIRY_BOUNDARIES = exports.SESSION_EXPIRY = exports.SESSION_CONTEXT = exports.REQUEST_QUEUE_STATES = exports.REQUEST_CONTEXT = exports.PROPOSAL_EXPIRY_MESSAGE = exports.PROPOSAL_EXPIRY = exports.PROPOSAL_CONTEXT = exports.METHODS_TO_VERIFY = exports.HISTORY_STORAGE_VERSION = exports.HISTORY_EVENTS = exports.HISTORY_CONTEXT = exports.ENGINE_RPC_OPTS = exports.ENGINE_CONTEXT = void 0;\nvar _core = require(\"@walletconnect/core\");\nvar _logger = require(\"@walletconnect/logger\");\nvar _types = require(\"@walletconnect/types\");\nvar _utils = require(\"@walletconnect/utils\");\nvar _events = _interopRequireWildcard(require(\"events\"));\nvar _time = require(\"@walletconnect/time\");\nvar _jsonrpcUtils = require(\"@walletconnect/jsonrpc-utils\");\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\nconst Y = exports.SIGN_CLIENT_PROTOCOL = \"wc\",\n  J = exports.SIGN_CLIENT_VERSION = 2,\n  X = exports.SIGN_CLIENT_CONTEXT = \"client\",\n  G = exports.SIGN_CLIENT_STORAGE_PREFIX = `${Y}@${J}:${X}:`,\n  $ = exports.SIGN_CLIENT_DEFAULT = {\n    name: X,\n    logger: \"error\",\n    controller: !1,\n    relayUrl: \"wss://relay.walletconnect.com\"\n  },\n  Fe = exports.SIGN_CLIENT_EVENTS = {\n    session_proposal: \"session_proposal\",\n    session_update: \"session_update\",\n    session_extend: \"session_extend\",\n    session_ping: \"session_ping\",\n    session_delete: \"session_delete\",\n    session_expire: \"session_expire\",\n    session_request: \"session_request\",\n    session_request_sent: \"session_request_sent\",\n    session_event: \"session_event\",\n    proposal_expire: \"proposal_expire\"\n  },\n  Be = exports.SIGN_CLIENT_STORAGE_OPTIONS = {\n    database: \":memory:\"\n  },\n  te = exports.WALLETCONNECT_DEEPLINK_CHOICE = \"WALLETCONNECT_DEEPLINK_CHOICE\",\n  We = exports.HISTORY_EVENTS = {\n    created: \"history_created\",\n    updated: \"history_updated\",\n    deleted: \"history_deleted\",\n    sync: \"history_sync\"\n  },\n  Ze = exports.HISTORY_CONTEXT = \"history\",\n  es = exports.HISTORY_STORAGE_VERSION = \"0.3\",\n  ie = exports.PROPOSAL_CONTEXT = \"proposal\",\n  ss = exports.PROPOSAL_EXPIRY = _time.THIRTY_DAYS,\n  re = exports.PROPOSAL_EXPIRY_MESSAGE = \"Proposal expired\",\n  ne = exports.SESSION_CONTEXT = \"session\",\n  A = exports.SESSION_EXPIRY = _time.SEVEN_DAYS,\n  oe = exports.ENGINE_CONTEXT = \"engine\",\n  O = exports.ENGINE_RPC_OPTS = {\n    wc_sessionPropose: {\n      req: {\n        ttl: _time.FIVE_MINUTES,\n        prompt: !0,\n        tag: 1100\n      },\n      res: {\n        ttl: _time.FIVE_MINUTES,\n        prompt: !1,\n        tag: 1101\n      }\n    },\n    wc_sessionSettle: {\n      req: {\n        ttl: _time.FIVE_MINUTES,\n        prompt: !1,\n        tag: 1102\n      },\n      res: {\n        ttl: _time.FIVE_MINUTES,\n        prompt: !1,\n        tag: 1103\n      }\n    },\n    wc_sessionUpdate: {\n      req: {\n        ttl: _time.ONE_DAY,\n        prompt: !1,\n        tag: 1104\n      },\n      res: {\n        ttl: _time.ONE_DAY,\n        prompt: !1,\n        tag: 1105\n      }\n    },\n    wc_sessionExtend: {\n      req: {\n        ttl: _time.ONE_DAY,\n        prompt: !1,\n        tag: 1106\n      },\n      res: {\n        ttl: _time.ONE_DAY,\n        prompt: !1,\n        tag: 1107\n      }\n    },\n    wc_sessionRequest: {\n      req: {\n        ttl: _time.FIVE_MINUTES,\n        prompt: !0,\n        tag: 1108\n      },\n      res: {\n        ttl: _time.FIVE_MINUTES,\n        prompt: !1,\n        tag: 1109\n      }\n    },\n    wc_sessionEvent: {\n      req: {\n        ttl: _time.FIVE_MINUTES,\n        prompt: !0,\n        tag: 1110\n      },\n      res: {\n        ttl: _time.FIVE_MINUTES,\n        prompt: !1,\n        tag: 1111\n      }\n    },\n    wc_sessionDelete: {\n      req: {\n        ttl: _time.ONE_DAY,\n        prompt: !1,\n        tag: 1112\n      },\n      res: {\n        ttl: _time.ONE_DAY,\n        prompt: !1,\n        tag: 1113\n      }\n    },\n    wc_sessionPing: {\n      req: {\n        ttl: _time.THIRTY_SECONDS,\n        prompt: !1,\n        tag: 1114\n      },\n      res: {\n        ttl: _time.THIRTY_SECONDS,\n        prompt: !1,\n        tag: 1115\n      }\n    }\n  },\n  M = exports.SESSION_REQUEST_EXPIRY_BOUNDARIES = {\n    min: _time.FIVE_MINUTES,\n    max: _time.SEVEN_DAYS\n  },\n  V = exports.REQUEST_QUEUE_STATES = {\n    idle: \"idle\",\n    active: \"active\"\n  },\n  ae = exports.REQUEST_CONTEXT = \"request\",\n  ce = exports.METHODS_TO_VERIFY = [\"wc_sessionPropose\", \"wc_sessionRequest\", \"wc_authRequest\"];\nvar ts = Object.defineProperty,\n  is = Object.defineProperties,\n  rs = Object.getOwnPropertyDescriptors,\n  le = Object.getOwnPropertySymbols,\n  ns = Object.prototype.hasOwnProperty,\n  os = Object.prototype.propertyIsEnumerable,\n  pe = (d, r, e) => r in d ? ts(d, r, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : d[r] = e,\n  w = (d, r) => {\n    for (var e in r || (r = {})) ns.call(r, e) && pe(d, e, r[e]);\n    if (le) for (var e of le(r)) os.call(r, e) && pe(d, e, r[e]);\n    return d;\n  },\n  H = (d, r) => is(d, rs(r));\nclass as extends _types.IEngine {\n  constructor(r) {\n    super(r), this.name = oe, this.events = new _events.default(), this.initialized = !1, this.ignoredPayloadTypes = [_utils.TYPE_1], this.requestQueue = {\n      state: V.idle,\n      requests: []\n    }, this.requestQueueDelay = _time.ONE_SECOND, this.init = async () => {\n      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.client.core.pairing.register({\n        methods: Object.keys(O)\n      }), this.initialized = !0, setTimeout(() => {\n        this.requestQueue.requests = this.getPendingSessionRequests(), this.processRequestQueue();\n      }, (0, _time.toMiliseconds)(this.requestQueueDelay)));\n    }, this.connect = async e => {\n      this.isInitialized();\n      const s = H(w({}, e), {\n        requiredNamespaces: e.requiredNamespaces || {},\n        optionalNamespaces: e.optionalNamespaces || {}\n      });\n      await this.isValidConnect(s);\n      const {\n        pairingTopic: t,\n        requiredNamespaces: i,\n        optionalNamespaces: n,\n        sessionProperties: o,\n        relays: a\n      } = s;\n      let l = t,\n        h,\n        E = !1;\n      if (l && (E = this.client.core.pairing.pairings.get(l).active), !l || !E) {\n        const {\n          topic: f,\n          uri: y\n        } = await this.client.core.pairing.create();\n        l = f, h = y;\n      }\n      const g = await this.client.core.crypto.generateKeyPair(),\n        I = w({\n          requiredNamespaces: i,\n          optionalNamespaces: n,\n          relays: a ?? [{\n            protocol: _core.RELAYER_DEFAULT_PROTOCOL\n          }],\n          proposer: {\n            publicKey: g,\n            metadata: this.client.metadata\n          }\n        }, o && {\n          sessionProperties: o\n        }),\n        {\n          reject: u,\n          resolve: T,\n          done: K\n        } = (0, _utils.createDelayedPromise)(_time.FIVE_MINUTES, re);\n      if (this.events.once((0, _utils.engineEvent)(\"session_connect\"), async ({\n        error: f,\n        session: y\n      }) => {\n        if (f) u(f);else if (y) {\n          y.self.publicKey = g;\n          const F = H(w({}, y), {\n            requiredNamespaces: y.requiredNamespaces,\n            optionalNamespaces: y.optionalNamespaces\n          });\n          await this.client.session.set(y.topic, F), await this.setExpiry(y.topic, y.expiry), l && (await this.client.core.pairing.updateMetadata({\n            topic: l,\n            metadata: y.peer.metadata\n          })), T(F);\n        }\n      }), !l) {\n        const {\n          message: f\n        } = (0, _utils.getInternalError)(\"NO_MATCHING_KEY\", `connect() pairing topic: ${l}`);\n        throw new Error(f);\n      }\n      const L = await this.sendRequest(l, \"wc_sessionPropose\", I),\n        he = (0, _utils.calcExpiry)(_time.FIVE_MINUTES);\n      return await this.setProposal(L, w({\n        id: L,\n        expiry: he\n      }, I)), {\n        uri: h,\n        approval: K\n      };\n    }, this.pair = async e => (this.isInitialized(), await this.client.core.pairing.pair(e)), this.approve = async e => {\n      this.isInitialized(), await this.isValidApprove(e);\n      const {\n          id: s,\n          relayProtocol: t,\n          namespaces: i,\n          sessionProperties: n\n        } = e,\n        o = this.client.proposal.get(s);\n      let {\n        pairingTopic: a,\n        proposer: l,\n        requiredNamespaces: h,\n        optionalNamespaces: E\n      } = o;\n      a = a || \"\", (0, _utils.isValidObject)(h) || (h = (0, _utils.getRequiredNamespacesFromNamespaces)(i, \"approve()\"));\n      const g = await this.client.core.crypto.generateKeyPair(),\n        I = l.publicKey,\n        u = await this.client.core.crypto.generateSharedKey(g, I);\n      a && s && (await this.client.core.pairing.updateMetadata({\n        topic: a,\n        metadata: l.metadata\n      }), await this.sendResult(s, a, {\n        relay: {\n          protocol: t ?? \"irn\"\n        },\n        responderPublicKey: g\n      }), await this.client.proposal.delete(s, (0, _utils.getSdkError)(\"USER_DISCONNECTED\")), await this.client.core.pairing.activate({\n        topic: a\n      }));\n      const T = w({\n        relay: {\n          protocol: t ?? \"irn\"\n        },\n        namespaces: i,\n        requiredNamespaces: h,\n        optionalNamespaces: E,\n        pairingTopic: a,\n        controller: {\n          publicKey: g,\n          metadata: this.client.metadata\n        },\n        expiry: (0, _utils.calcExpiry)(A)\n      }, n && {\n        sessionProperties: n\n      });\n      await this.client.core.relayer.subscribe(u), await this.sendRequest(u, \"wc_sessionSettle\", T);\n      const K = H(w({}, T), {\n        topic: u,\n        pairingTopic: a,\n        acknowledged: !1,\n        self: T.controller,\n        peer: {\n          publicKey: l.publicKey,\n          metadata: l.metadata\n        },\n        controller: g\n      });\n      return await this.client.session.set(u, K), await this.setExpiry(u, (0, _utils.calcExpiry)(A)), {\n        topic: u,\n        acknowledged: () => new Promise(L => setTimeout(() => L(this.client.session.get(u)), 500))\n      };\n    }, this.reject = async e => {\n      this.isInitialized(), await this.isValidReject(e);\n      const {\n          id: s,\n          reason: t\n        } = e,\n        {\n          pairingTopic: i\n        } = this.client.proposal.get(s);\n      i && (await this.sendError(s, i, t), await this.client.proposal.delete(s, (0, _utils.getSdkError)(\"USER_DISCONNECTED\")));\n    }, this.update = async e => {\n      this.isInitialized(), await this.isValidUpdate(e);\n      const {\n          topic: s,\n          namespaces: t\n        } = e,\n        i = await this.sendRequest(s, \"wc_sessionUpdate\", {\n          namespaces: t\n        }),\n        {\n          done: n,\n          resolve: o,\n          reject: a\n        } = (0, _utils.createDelayedPromise)();\n      return this.events.once((0, _utils.engineEvent)(\"session_update\", i), ({\n        error: l\n      }) => {\n        l ? a(l) : o();\n      }), await this.client.session.update(s, {\n        namespaces: t\n      }), {\n        acknowledged: n\n      };\n    }, this.extend = async e => {\n      this.isInitialized(), await this.isValidExtend(e);\n      const {\n          topic: s\n        } = e,\n        t = await this.sendRequest(s, \"wc_sessionExtend\", {}),\n        {\n          done: i,\n          resolve: n,\n          reject: o\n        } = (0, _utils.createDelayedPromise)();\n      return this.events.once((0, _utils.engineEvent)(\"session_extend\", t), ({\n        error: a\n      }) => {\n        a ? o(a) : n();\n      }), await this.setExpiry(s, (0, _utils.calcExpiry)(A)), {\n        acknowledged: i\n      };\n    }, this.request = async e => {\n      this.isInitialized(), await this.isValidRequest(e);\n      const {\n          chainId: s,\n          request: t,\n          topic: i,\n          expiry: n\n        } = e,\n        o = await this.sendRequest(i, \"wc_sessionRequest\", {\n          request: t,\n          chainId: s\n        }, n),\n        {\n          done: a,\n          resolve: l,\n          reject: h\n        } = (0, _utils.createDelayedPromise)(n);\n      this.events.once((0, _utils.engineEvent)(\"session_request\", o), ({\n        error: g,\n        result: I\n      }) => {\n        g ? h(g) : l(I);\n      }), this.client.events.emit(\"session_request_sent\", {\n        topic: i,\n        request: t,\n        chainId: s,\n        id: o\n      });\n      const E = await this.client.core.storage.getItem(te);\n      return (0, _utils.handleDeeplinkRedirect)({\n        id: o,\n        topic: i,\n        wcDeepLink: E\n      }), await a();\n    }, this.respond = async e => {\n      this.isInitialized(), await this.isValidRespond(e);\n      const {\n          topic: s,\n          response: t\n        } = e,\n        {\n          id: i\n        } = t;\n      (0, _jsonrpcUtils.isJsonRpcResult)(t) ? await this.sendResult(i, s, t.result) : (0, _jsonrpcUtils.isJsonRpcError)(t) && (await this.sendError(i, s, t.error)), this.cleanupAfterResponse(e);\n    }, this.ping = async e => {\n      this.isInitialized(), await this.isValidPing(e);\n      const {\n        topic: s\n      } = e;\n      if (this.client.session.keys.includes(s)) {\n        const t = await this.sendRequest(s, \"wc_sessionPing\", {}),\n          {\n            done: i,\n            resolve: n,\n            reject: o\n          } = (0, _utils.createDelayedPromise)();\n        this.events.once((0, _utils.engineEvent)(\"session_ping\", t), ({\n          error: a\n        }) => {\n          a ? o(a) : n();\n        }), await i();\n      } else this.client.core.pairing.pairings.keys.includes(s) && (await this.client.core.pairing.ping({\n        topic: s\n      }));\n    }, this.emit = async e => {\n      this.isInitialized(), await this.isValidEmit(e);\n      const {\n        topic: s,\n        event: t,\n        chainId: i\n      } = e;\n      await this.sendRequest(s, \"wc_sessionEvent\", {\n        event: t,\n        chainId: i\n      });\n    }, this.disconnect = async e => {\n      this.isInitialized(), await this.isValidDisconnect(e);\n      const {\n        topic: s\n      } = e;\n      if (this.client.session.keys.includes(s)) {\n        const t = (0, _jsonrpcUtils.getBigIntRpcId)().toString();\n        let i;\n        const n = o => {\n          o?.id.toString() === t && (this.client.core.relayer.events.removeListener(_core.RELAYER_EVENTS.message_ack, n), i());\n        };\n        await Promise.all([new Promise(o => {\n          i = o, this.client.core.relayer.on(_core.RELAYER_EVENTS.message_ack, n);\n        }), this.sendRequest(s, \"wc_sessionDelete\", (0, _utils.getSdkError)(\"USER_DISCONNECTED\"), void 0, t)]), await this.deleteSession(s);\n      } else await this.client.core.pairing.disconnect({\n        topic: s\n      });\n    }, this.find = e => (this.isInitialized(), this.client.session.getAll().filter(s => (0, _utils.isSessionCompatible)(s, e))), this.getPendingSessionRequests = () => (this.isInitialized(), this.client.pendingRequest.getAll()), this.cleanupDuplicatePairings = async e => {\n      if (e.pairingTopic) try {\n        const s = this.client.core.pairing.pairings.get(e.pairingTopic),\n          t = this.client.core.pairing.pairings.getAll().filter(i => {\n            var n, o;\n            return ((n = i.peerMetadata) == null ? void 0 : n.url) && ((o = i.peerMetadata) == null ? void 0 : o.url) === e.peer.metadata.url && i.topic && i.topic !== s.topic;\n          });\n        if (t.length === 0) return;\n        this.client.logger.info(`Cleaning up ${t.length} duplicate pairing(s)`), await Promise.all(t.map(i => this.client.core.pairing.disconnect({\n          topic: i.topic\n        }))), this.client.logger.info(\"Duplicate pairings clean up finished\");\n      } catch (s) {\n        this.client.logger.error(s);\n      }\n    }, this.deleteSession = async (e, s) => {\n      const {\n        self: t\n      } = this.client.session.get(e);\n      await this.client.core.relayer.unsubscribe(e), this.client.session.delete(e, (0, _utils.getSdkError)(\"USER_DISCONNECTED\")), this.client.core.crypto.keychain.has(t.publicKey) && (await this.client.core.crypto.deleteKeyPair(t.publicKey)), this.client.core.crypto.keychain.has(e) && (await this.client.core.crypto.deleteSymKey(e)), s || this.client.core.expirer.del(e);\n    }, this.deleteProposal = async (e, s) => {\n      await Promise.all([this.client.proposal.delete(e, (0, _utils.getSdkError)(\"USER_DISCONNECTED\")), s ? Promise.resolve() : this.client.core.expirer.del(e)]);\n    }, this.deletePendingSessionRequest = async (e, s, t = !1) => {\n      await Promise.all([this.client.pendingRequest.delete(e, s), t ? Promise.resolve() : this.client.core.expirer.del(e)]), this.requestQueue.requests = this.requestQueue.requests.filter(i => i.id !== e), t && (this.requestQueue.state = V.idle);\n    }, this.setExpiry = async (e, s) => {\n      this.client.session.keys.includes(e) && (await this.client.session.update(e, {\n        expiry: s\n      })), this.client.core.expirer.set(e, s);\n    }, this.setProposal = async (e, s) => {\n      await this.client.proposal.set(e, s), this.client.core.expirer.set(e, s.expiry);\n    }, this.setPendingSessionRequest = async e => {\n      const s = O.wc_sessionRequest.req.ttl,\n        {\n          id: t,\n          topic: i,\n          params: n\n        } = e;\n      await this.client.pendingRequest.set(t, {\n        id: t,\n        topic: i,\n        params: n\n      }), s && this.client.core.expirer.set(t, (0, _utils.calcExpiry)(s));\n    }, this.sendRequest = async (e, s, t, i, n) => {\n      const o = (0, _jsonrpcUtils.formatJsonRpcRequest)(s, t);\n      if ((0, _utils.isBrowser)() && ce.includes(s)) {\n        const h = (0, _utils.hashMessage)(JSON.stringify(o));\n        await this.client.core.verify.register({\n          attestationId: h\n        });\n      }\n      const a = await this.client.core.crypto.encode(e, o),\n        l = O[s].req;\n      return i && (l.ttl = i), n && (l.id = n), this.client.core.history.set(e, o), this.client.core.relayer.publish(e, a, l), o.id;\n    }, this.sendResult = async (e, s, t) => {\n      const i = (0, _jsonrpcUtils.formatJsonRpcResult)(e, t),\n        n = await this.client.core.crypto.encode(s, i),\n        o = await this.client.core.history.get(s, e),\n        a = O[o.request.method].res;\n      this.client.core.relayer.publish(s, n, a), await this.client.core.history.resolve(i);\n    }, this.sendError = async (e, s, t) => {\n      const i = (0, _jsonrpcUtils.formatJsonRpcError)(e, t),\n        n = await this.client.core.crypto.encode(s, i),\n        o = await this.client.core.history.get(s, e),\n        a = O[o.request.method].res;\n      this.client.core.relayer.publish(s, n, a), await this.client.core.history.resolve(i);\n    }, this.cleanup = async () => {\n      const e = [],\n        s = [];\n      this.client.session.getAll().forEach(t => {\n        (0, _utils.isExpired)(t.expiry) && e.push(t.topic);\n      }), this.client.proposal.getAll().forEach(t => {\n        (0, _utils.isExpired)(t.expiry) && s.push(t.id);\n      }), await Promise.all([...e.map(t => this.deleteSession(t)), ...s.map(t => this.deleteProposal(t))]);\n    }, this.onRelayEventRequest = e => {\n      const {\n          topic: s,\n          payload: t\n        } = e,\n        i = t.method;\n      switch (i) {\n        case \"wc_sessionPropose\":\n          return this.onSessionProposeRequest(s, t);\n        case \"wc_sessionSettle\":\n          return this.onSessionSettleRequest(s, t);\n        case \"wc_sessionUpdate\":\n          return this.onSessionUpdateRequest(s, t);\n        case \"wc_sessionExtend\":\n          return this.onSessionExtendRequest(s, t);\n        case \"wc_sessionPing\":\n          return this.onSessionPingRequest(s, t);\n        case \"wc_sessionDelete\":\n          return this.onSessionDeleteRequest(s, t);\n        case \"wc_sessionRequest\":\n          return this.onSessionRequest(s, t);\n        case \"wc_sessionEvent\":\n          return this.onSessionEventRequest(s, t);\n        default:\n          return this.client.logger.info(`Unsupported request method ${i}`);\n      }\n    }, this.onRelayEventResponse = async e => {\n      const {\n          topic: s,\n          payload: t\n        } = e,\n        i = (await this.client.core.history.get(s, t.id)).request.method;\n      switch (i) {\n        case \"wc_sessionPropose\":\n          return this.onSessionProposeResponse(s, t);\n        case \"wc_sessionSettle\":\n          return this.onSessionSettleResponse(s, t);\n        case \"wc_sessionUpdate\":\n          return this.onSessionUpdateResponse(s, t);\n        case \"wc_sessionExtend\":\n          return this.onSessionExtendResponse(s, t);\n        case \"wc_sessionPing\":\n          return this.onSessionPingResponse(s, t);\n        case \"wc_sessionRequest\":\n          return this.onSessionRequestResponse(s, t);\n        default:\n          return this.client.logger.info(`Unsupported response method ${i}`);\n      }\n    }, this.onRelayEventUnknownPayload = e => {\n      const {\n          topic: s\n        } = e,\n        {\n          message: t\n        } = (0, _utils.getInternalError)(\"MISSING_OR_INVALID\", `Decoded payload on topic ${s} is not identifiable as a JSON-RPC request or a response.`);\n      throw new Error(t);\n    }, this.onSessionProposeRequest = async (e, s) => {\n      const {\n        params: t,\n        id: i\n      } = s;\n      try {\n        this.isValidConnect(w({}, s.params));\n        const n = (0, _utils.calcExpiry)(_time.FIVE_MINUTES),\n          o = w({\n            id: i,\n            pairingTopic: e,\n            expiry: n\n          }, t);\n        await this.setProposal(i, o);\n        const a = (0, _utils.hashMessage)(JSON.stringify(s)),\n          l = await this.getVerifyContext(a, o.proposer.metadata);\n        this.client.events.emit(\"session_proposal\", {\n          id: i,\n          params: o,\n          verifyContext: l\n        });\n      } catch (n) {\n        await this.sendError(i, e, n), this.client.logger.error(n);\n      }\n    }, this.onSessionProposeResponse = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      if ((0, _jsonrpcUtils.isJsonRpcResult)(s)) {\n        const {\n          result: i\n        } = s;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          result: i\n        });\n        const n = this.client.proposal.get(t);\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          proposal: n\n        });\n        const o = n.proposer.publicKey;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          selfPublicKey: o\n        });\n        const a = i.responderPublicKey;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          peerPublicKey: a\n        });\n        const l = await this.client.core.crypto.generateSharedKey(o, a);\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          sessionTopic: l\n        });\n        const h = await this.client.core.relayer.subscribe(l);\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          subscriptionId: h\n        }), await this.client.core.pairing.activate({\n          topic: e\n        });\n      } else (0, _jsonrpcUtils.isJsonRpcError)(s) && (await this.client.proposal.delete(t, (0, _utils.getSdkError)(\"USER_DISCONNECTED\")), this.events.emit((0, _utils.engineEvent)(\"session_connect\"), {\n        error: s.error\n      }));\n    }, this.onSessionSettleRequest = async (e, s) => {\n      const {\n        id: t,\n        params: i\n      } = s;\n      try {\n        this.isValidSessionSettleRequest(i);\n        const {\n            relay: n,\n            controller: o,\n            expiry: a,\n            namespaces: l,\n            requiredNamespaces: h,\n            optionalNamespaces: E,\n            sessionProperties: g,\n            pairingTopic: I\n          } = s.params,\n          u = w({\n            topic: e,\n            relay: n,\n            expiry: a,\n            namespaces: l,\n            acknowledged: !0,\n            pairingTopic: I,\n            requiredNamespaces: h,\n            optionalNamespaces: E,\n            controller: o.publicKey,\n            self: {\n              publicKey: \"\",\n              metadata: this.client.metadata\n            },\n            peer: {\n              publicKey: o.publicKey,\n              metadata: o.metadata\n            }\n          }, g && {\n            sessionProperties: g\n          });\n        await this.sendResult(s.id, e, !0), this.events.emit((0, _utils.engineEvent)(\"session_connect\"), {\n          session: u\n        }), this.cleanupDuplicatePairings(u);\n      } catch (n) {\n        await this.sendError(t, e, n), this.client.logger.error(n);\n      }\n    }, this.onSessionSettleResponse = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      (0, _jsonrpcUtils.isJsonRpcResult)(s) ? (await this.client.session.update(e, {\n        acknowledged: !0\n      }), this.events.emit((0, _utils.engineEvent)(\"session_approve\", t), {})) : (0, _jsonrpcUtils.isJsonRpcError)(s) && (await this.client.session.delete(e, (0, _utils.getSdkError)(\"USER_DISCONNECTED\")), this.events.emit((0, _utils.engineEvent)(\"session_approve\", t), {\n        error: s.error\n      }));\n    }, this.onSessionUpdateRequest = async (e, s) => {\n      const {\n        params: t,\n        id: i\n      } = s;\n      try {\n        this.isValidUpdate(w({\n          topic: e\n        }, t)), await this.client.session.update(e, {\n          namespaces: t.namespaces\n        }), await this.sendResult(i, e, !0), this.client.events.emit(\"session_update\", {\n          id: i,\n          topic: e,\n          params: t\n        });\n      } catch (n) {\n        await this.sendError(i, e, n), this.client.logger.error(n);\n      }\n    }, this.onSessionUpdateResponse = (e, s) => {\n      const {\n        id: t\n      } = s;\n      (0, _jsonrpcUtils.isJsonRpcResult)(s) ? this.events.emit((0, _utils.engineEvent)(\"session_update\", t), {}) : (0, _jsonrpcUtils.isJsonRpcError)(s) && this.events.emit((0, _utils.engineEvent)(\"session_update\", t), {\n        error: s.error\n      });\n    }, this.onSessionExtendRequest = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      try {\n        this.isValidExtend({\n          topic: e\n        }), await this.setExpiry(e, (0, _utils.calcExpiry)(A)), await this.sendResult(t, e, !0), this.client.events.emit(\"session_extend\", {\n          id: t,\n          topic: e\n        });\n      } catch (i) {\n        await this.sendError(t, e, i), this.client.logger.error(i);\n      }\n    }, this.onSessionExtendResponse = (e, s) => {\n      const {\n        id: t\n      } = s;\n      (0, _jsonrpcUtils.isJsonRpcResult)(s) ? this.events.emit((0, _utils.engineEvent)(\"session_extend\", t), {}) : (0, _jsonrpcUtils.isJsonRpcError)(s) && this.events.emit((0, _utils.engineEvent)(\"session_extend\", t), {\n        error: s.error\n      });\n    }, this.onSessionPingRequest = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      try {\n        this.isValidPing({\n          topic: e\n        }), await this.sendResult(t, e, !0), this.client.events.emit(\"session_ping\", {\n          id: t,\n          topic: e\n        });\n      } catch (i) {\n        await this.sendError(t, e, i), this.client.logger.error(i);\n      }\n    }, this.onSessionPingResponse = (e, s) => {\n      const {\n        id: t\n      } = s;\n      setTimeout(() => {\n        (0, _jsonrpcUtils.isJsonRpcResult)(s) ? this.events.emit((0, _utils.engineEvent)(\"session_ping\", t), {}) : (0, _jsonrpcUtils.isJsonRpcError)(s) && this.events.emit((0, _utils.engineEvent)(\"session_ping\", t), {\n          error: s.error\n        });\n      }, 500);\n    }, this.onSessionDeleteRequest = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      try {\n        this.isValidDisconnect({\n          topic: e,\n          reason: s.params\n        }), await Promise.all([new Promise(i => {\n          this.client.core.relayer.once(_core.RELAYER_EVENTS.publish, async () => {\n            i(await this.deleteSession(e));\n          });\n        }), this.sendResult(t, e, !0)]), this.client.events.emit(\"session_delete\", {\n          id: t,\n          topic: e\n        });\n      } catch (i) {\n        this.client.logger.error(i);\n      }\n    }, this.onSessionRequest = async (e, s) => {\n      const {\n        id: t,\n        params: i\n      } = s;\n      try {\n        this.isValidRequest(w({\n          topic: e\n        }, i)), await this.setPendingSessionRequest({\n          id: t,\n          topic: e,\n          params: i\n        }), this.addRequestToQueue({\n          id: t,\n          topic: e,\n          params: i\n        }), await this.processRequestQueue();\n      } catch (n) {\n        await this.sendError(t, e, n), this.client.logger.error(n);\n      }\n    }, this.onSessionRequestResponse = (e, s) => {\n      const {\n        id: t\n      } = s;\n      (0, _jsonrpcUtils.isJsonRpcResult)(s) ? this.events.emit((0, _utils.engineEvent)(\"session_request\", t), {\n        result: s.result\n      }) : (0, _jsonrpcUtils.isJsonRpcError)(s) && this.events.emit((0, _utils.engineEvent)(\"session_request\", t), {\n        error: s.error\n      });\n    }, this.onSessionEventRequest = async (e, s) => {\n      const {\n        id: t,\n        params: i\n      } = s;\n      try {\n        this.isValidEmit(w({\n          topic: e\n        }, i)), this.client.events.emit(\"session_event\", {\n          id: t,\n          topic: e,\n          params: i\n        });\n      } catch (n) {\n        await this.sendError(t, e, n), this.client.logger.error(n);\n      }\n    }, this.addRequestToQueue = e => {\n      this.requestQueue.requests.push(e);\n    }, this.cleanupAfterResponse = e => {\n      this.deletePendingSessionRequest(e.response.id, {\n        message: \"fulfilled\",\n        code: 0\n      }), setTimeout(() => {\n        this.requestQueue.state = V.idle, this.processRequestQueue();\n      }, (0, _time.toMiliseconds)(this.requestQueueDelay));\n    }, this.processRequestQueue = async () => {\n      if (this.requestQueue.state === V.active) {\n        this.client.logger.info(\"session request queue is already active.\");\n        return;\n      }\n      const e = this.requestQueue.requests[0];\n      if (!e) {\n        this.client.logger.info(\"session request queue is empty.\");\n        return;\n      }\n      try {\n        const {\n            id: s,\n            topic: t,\n            params: i\n          } = e,\n          n = (0, _utils.hashMessage)(JSON.stringify({\n            id: s,\n            params: i\n          })),\n          o = this.client.session.get(t),\n          a = await this.getVerifyContext(n, o.peer.metadata);\n        this.requestQueue.state = V.active, this.client.events.emit(\"session_request\", {\n          id: s,\n          topic: t,\n          params: i,\n          verifyContext: a\n        });\n      } catch (s) {\n        this.client.logger.error(s);\n      }\n    }, this.isValidConnect = async e => {\n      if (!(0, _utils.isValidParams)(e)) {\n        const {\n          message: a\n        } = (0, _utils.getInternalError)(\"MISSING_OR_INVALID\", `connect() params: ${JSON.stringify(e)}`);\n        throw new Error(a);\n      }\n      const {\n        pairingTopic: s,\n        requiredNamespaces: t,\n        optionalNamespaces: i,\n        sessionProperties: n,\n        relays: o\n      } = e;\n      if ((0, _utils.isUndefined)(s) || (await this.isValidPairingTopic(s)), !(0, _utils.isValidRelays)(o, !0)) {\n        const {\n          message: a\n        } = (0, _utils.getInternalError)(\"MISSING_OR_INVALID\", `connect() relays: ${o}`);\n        throw new Error(a);\n      }\n      !(0, _utils.isUndefined)(t) && (0, _utils.isValidObject)(t) !== 0 && this.validateNamespaces(t, \"requiredNamespaces\"), !(0, _utils.isUndefined)(i) && (0, _utils.isValidObject)(i) !== 0 && this.validateNamespaces(i, \"optionalNamespaces\"), (0, _utils.isUndefined)(n) || this.validateSessionProps(n, \"sessionProperties\");\n    }, this.validateNamespaces = (e, s) => {\n      const t = (0, _utils.isValidRequiredNamespaces)(e, \"connect()\", s);\n      if (t) throw new Error(t.message);\n    }, this.isValidApprove = async e => {\n      if (!(0, _utils.isValidParams)(e)) throw new Error((0, _utils.getInternalError)(\"MISSING_OR_INVALID\", `approve() params: ${e}`).message);\n      const {\n        id: s,\n        namespaces: t,\n        relayProtocol: i,\n        sessionProperties: n\n      } = e;\n      await this.isValidProposalId(s);\n      const o = this.client.proposal.get(s),\n        a = (0, _utils.isValidNamespaces)(t, \"approve()\");\n      if (a) throw new Error(a.message);\n      const l = (0, _utils.isConformingNamespaces)(o.requiredNamespaces, t, \"approve()\");\n      if (l) throw new Error(l.message);\n      if (!(0, _utils.isValidString)(i, !0)) {\n        const {\n          message: h\n        } = (0, _utils.getInternalError)(\"MISSING_OR_INVALID\", `approve() relayProtocol: ${i}`);\n        throw new Error(h);\n      }\n      (0, _utils.isUndefined)(n) || this.validateSessionProps(n, \"sessionProperties\");\n    }, this.isValidReject = async e => {\n      if (!(0, _utils.isValidParams)(e)) {\n        const {\n          message: i\n        } = (0, _utils.getInternalError)(\"MISSING_OR_INVALID\", `reject() params: ${e}`);\n        throw new Error(i);\n      }\n      const {\n        id: s,\n        reason: t\n      } = e;\n      if (await this.isValidProposalId(s), !(0, _utils.isValidErrorReason)(t)) {\n        const {\n          message: i\n        } = (0, _utils.getInternalError)(\"MISSING_OR_INVALID\", `reject() reason: ${JSON.stringify(t)}`);\n        throw new Error(i);\n      }\n    }, this.isValidSessionSettleRequest = e => {\n      if (!(0, _utils.isValidParams)(e)) {\n        const {\n          message: l\n        } = (0, _utils.getInternalError)(\"MISSING_OR_INVALID\", `onSessionSettleRequest() params: ${e}`);\n        throw new Error(l);\n      }\n      const {\n        relay: s,\n        controller: t,\n        namespaces: i,\n        expiry: n\n      } = e;\n      if (!(0, _utils.isValidRelay)(s)) {\n        const {\n          message: l\n        } = (0, _utils.getInternalError)(\"MISSING_OR_INVALID\", \"onSessionSettleRequest() relay protocol should be a string\");\n        throw new Error(l);\n      }\n      const o = (0, _utils.isValidController)(t, \"onSessionSettleRequest()\");\n      if (o) throw new Error(o.message);\n      const a = (0, _utils.isValidNamespaces)(i, \"onSessionSettleRequest()\");\n      if (a) throw new Error(a.message);\n      if ((0, _utils.isExpired)(n)) {\n        const {\n          message: l\n        } = (0, _utils.getInternalError)(\"EXPIRED\", \"onSessionSettleRequest()\");\n        throw new Error(l);\n      }\n    }, this.isValidUpdate = async e => {\n      if (!(0, _utils.isValidParams)(e)) {\n        const {\n          message: a\n        } = (0, _utils.getInternalError)(\"MISSING_OR_INVALID\", `update() params: ${e}`);\n        throw new Error(a);\n      }\n      const {\n        topic: s,\n        namespaces: t\n      } = e;\n      await this.isValidSessionTopic(s);\n      const i = this.client.session.get(s),\n        n = (0, _utils.isValidNamespaces)(t, \"update()\");\n      if (n) throw new Error(n.message);\n      const o = (0, _utils.isConformingNamespaces)(i.requiredNamespaces, t, \"update()\");\n      if (o) throw new Error(o.message);\n    }, this.isValidExtend = async e => {\n      if (!(0, _utils.isValidParams)(e)) {\n        const {\n          message: t\n        } = (0, _utils.getInternalError)(\"MISSING_OR_INVALID\", `extend() params: ${e}`);\n        throw new Error(t);\n      }\n      const {\n        topic: s\n      } = e;\n      await this.isValidSessionTopic(s);\n    }, this.isValidRequest = async e => {\n      if (!(0, _utils.isValidParams)(e)) {\n        const {\n          message: a\n        } = (0, _utils.getInternalError)(\"MISSING_OR_INVALID\", `request() params: ${e}`);\n        throw new Error(a);\n      }\n      const {\n        topic: s,\n        request: t,\n        chainId: i,\n        expiry: n\n      } = e;\n      await this.isValidSessionTopic(s);\n      const {\n        namespaces: o\n      } = this.client.session.get(s);\n      if (!(0, _utils.isValidNamespacesChainId)(o, i)) {\n        const {\n          message: a\n        } = (0, _utils.getInternalError)(\"MISSING_OR_INVALID\", `request() chainId: ${i}`);\n        throw new Error(a);\n      }\n      if (!(0, _utils.isValidRequest)(t)) {\n        const {\n          message: a\n        } = (0, _utils.getInternalError)(\"MISSING_OR_INVALID\", `request() ${JSON.stringify(t)}`);\n        throw new Error(a);\n      }\n      if (!(0, _utils.isValidNamespacesRequest)(o, i, t.method)) {\n        const {\n          message: a\n        } = (0, _utils.getInternalError)(\"MISSING_OR_INVALID\", `request() method: ${t.method}`);\n        throw new Error(a);\n      }\n      if (n && !(0, _utils.isValidRequestExpiry)(n, M)) {\n        const {\n          message: a\n        } = (0, _utils.getInternalError)(\"MISSING_OR_INVALID\", `request() expiry: ${n}. Expiry must be a number (in seconds) between ${M.min} and ${M.max}`);\n        throw new Error(a);\n      }\n    }, this.isValidRespond = async e => {\n      if (!(0, _utils.isValidParams)(e)) {\n        const {\n          message: i\n        } = (0, _utils.getInternalError)(\"MISSING_OR_INVALID\", `respond() params: ${e}`);\n        throw new Error(i);\n      }\n      const {\n        topic: s,\n        response: t\n      } = e;\n      if (await this.isValidSessionTopic(s), !(0, _utils.isValidResponse)(t)) {\n        const {\n          message: i\n        } = (0, _utils.getInternalError)(\"MISSING_OR_INVALID\", `respond() response: ${JSON.stringify(t)}`);\n        throw new Error(i);\n      }\n    }, this.isValidPing = async e => {\n      if (!(0, _utils.isValidParams)(e)) {\n        const {\n          message: t\n        } = (0, _utils.getInternalError)(\"MISSING_OR_INVALID\", `ping() params: ${e}`);\n        throw new Error(t);\n      }\n      const {\n        topic: s\n      } = e;\n      await this.isValidSessionOrPairingTopic(s);\n    }, this.isValidEmit = async e => {\n      if (!(0, _utils.isValidParams)(e)) {\n        const {\n          message: o\n        } = (0, _utils.getInternalError)(\"MISSING_OR_INVALID\", `emit() params: ${e}`);\n        throw new Error(o);\n      }\n      const {\n        topic: s,\n        event: t,\n        chainId: i\n      } = e;\n      await this.isValidSessionTopic(s);\n      const {\n        namespaces: n\n      } = this.client.session.get(s);\n      if (!(0, _utils.isValidNamespacesChainId)(n, i)) {\n        const {\n          message: o\n        } = (0, _utils.getInternalError)(\"MISSING_OR_INVALID\", `emit() chainId: ${i}`);\n        throw new Error(o);\n      }\n      if (!(0, _utils.isValidEvent)(t)) {\n        const {\n          message: o\n        } = (0, _utils.getInternalError)(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(t)}`);\n        throw new Error(o);\n      }\n      if (!(0, _utils.isValidNamespacesEvent)(n, i, t.name)) {\n        const {\n          message: o\n        } = (0, _utils.getInternalError)(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(t)}`);\n        throw new Error(o);\n      }\n    }, this.isValidDisconnect = async e => {\n      if (!(0, _utils.isValidParams)(e)) {\n        const {\n          message: t\n        } = (0, _utils.getInternalError)(\"MISSING_OR_INVALID\", `disconnect() params: ${e}`);\n        throw new Error(t);\n      }\n      const {\n        topic: s\n      } = e;\n      await this.isValidSessionOrPairingTopic(s);\n    }, this.getVerifyContext = async (e, s) => {\n      const t = {\n        verified: {\n          verifyUrl: s.verifyUrl || \"\",\n          validation: \"UNKNOWN\",\n          origin: s.url || \"\"\n        }\n      };\n      try {\n        const i = await this.client.core.verify.resolve({\n          attestationId: e,\n          verifyUrl: s.verifyUrl\n        });\n        i && (t.verified.origin = i, t.verified.validation = i === s.url ? \"VALID\" : \"INVALID\");\n      } catch (i) {\n        this.client.logger.error(i);\n      }\n      return this.client.logger.info(`Verify context: ${JSON.stringify(t)}`), t;\n    }, this.validateSessionProps = (e, s) => {\n      Object.values(e).forEach(t => {\n        if (!(0, _utils.isValidString)(t, !1)) {\n          const {\n            message: i\n          } = (0, _utils.getInternalError)(\"MISSING_OR_INVALID\", `${s} must be in Record<string, string> format. Received: ${JSON.stringify(t)}`);\n          throw new Error(i);\n        }\n      });\n    };\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: r\n      } = (0, _utils.getInternalError)(\"NOT_INITIALIZED\", this.name);\n      throw new Error(r);\n    }\n  }\n  registerRelayerEvents() {\n    this.client.core.relayer.on(_core.RELAYER_EVENTS.message, async r => {\n      const {\n        topic: e,\n        message: s\n      } = r;\n      if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(s))) return;\n      const t = await this.client.core.crypto.decode(e, s);\n      (0, _jsonrpcUtils.isJsonRpcRequest)(t) ? (this.client.core.history.set(e, t), this.onRelayEventRequest({\n        topic: e,\n        payload: t\n      })) : (0, _jsonrpcUtils.isJsonRpcResponse)(t) ? (await this.client.core.history.resolve(t), await this.onRelayEventResponse({\n        topic: e,\n        payload: t\n      }), this.client.core.history.delete(e, t.id)) : this.onRelayEventUnknownPayload({\n        topic: e,\n        payload: t\n      });\n    });\n  }\n  registerExpirerEvents() {\n    this.client.core.expirer.on(_core.EXPIRER_EVENTS.expired, async r => {\n      const {\n        topic: e,\n        id: s\n      } = (0, _utils.parseExpirerTarget)(r.target);\n      if (s && this.client.pendingRequest.keys.includes(s)) return await this.deletePendingSessionRequest(s, (0, _utils.getInternalError)(\"EXPIRED\"), !0);\n      e ? this.client.session.keys.includes(e) && (await this.deleteSession(e, !0), this.client.events.emit(\"session_expire\", {\n        topic: e\n      })) : s && (await this.deleteProposal(s, !0), this.client.events.emit(\"proposal_expire\", {\n        id: s\n      }));\n    });\n  }\n  isValidPairingTopic(r) {\n    if (!(0, _utils.isValidString)(r, !1)) {\n      const {\n        message: e\n      } = (0, _utils.getInternalError)(\"MISSING_OR_INVALID\", `pairing topic should be a string: ${r}`);\n      throw new Error(e);\n    }\n    if (!this.client.core.pairing.pairings.keys.includes(r)) {\n      const {\n        message: e\n      } = (0, _utils.getInternalError)(\"NO_MATCHING_KEY\", `pairing topic doesn't exist: ${r}`);\n      throw new Error(e);\n    }\n    if ((0, _utils.isExpired)(this.client.core.pairing.pairings.get(r).expiry)) {\n      const {\n        message: e\n      } = (0, _utils.getInternalError)(\"EXPIRED\", `pairing topic: ${r}`);\n      throw new Error(e);\n    }\n  }\n  async isValidSessionTopic(r) {\n    if (!(0, _utils.isValidString)(r, !1)) {\n      const {\n        message: e\n      } = (0, _utils.getInternalError)(\"MISSING_OR_INVALID\", `session topic should be a string: ${r}`);\n      throw new Error(e);\n    }\n    if (!this.client.session.keys.includes(r)) {\n      const {\n        message: e\n      } = (0, _utils.getInternalError)(\"NO_MATCHING_KEY\", `session topic doesn't exist: ${r}`);\n      throw new Error(e);\n    }\n    if ((0, _utils.isExpired)(this.client.session.get(r).expiry)) {\n      await this.deleteSession(r);\n      const {\n        message: e\n      } = (0, _utils.getInternalError)(\"EXPIRED\", `session topic: ${r}`);\n      throw new Error(e);\n    }\n  }\n  async isValidSessionOrPairingTopic(r) {\n    if (this.client.session.keys.includes(r)) await this.isValidSessionTopic(r);else if (this.client.core.pairing.pairings.keys.includes(r)) this.isValidPairingTopic(r);else if ((0, _utils.isValidString)(r, !1)) {\n      const {\n        message: e\n      } = (0, _utils.getInternalError)(\"NO_MATCHING_KEY\", `session or pairing topic doesn't exist: ${r}`);\n      throw new Error(e);\n    } else {\n      const {\n        message: e\n      } = (0, _utils.getInternalError)(\"MISSING_OR_INVALID\", `session or pairing topic should be a string: ${r}`);\n      throw new Error(e);\n    }\n  }\n  async isValidProposalId(r) {\n    if (!(0, _utils.isValidId)(r)) {\n      const {\n        message: e\n      } = (0, _utils.getInternalError)(\"MISSING_OR_INVALID\", `proposal id should be a number: ${r}`);\n      throw new Error(e);\n    }\n    if (!this.client.proposal.keys.includes(r)) {\n      const {\n        message: e\n      } = (0, _utils.getInternalError)(\"NO_MATCHING_KEY\", `proposal id doesn't exist: ${r}`);\n      throw new Error(e);\n    }\n    if ((0, _utils.isExpired)(this.client.proposal.get(r).expiry)) {\n      await this.deleteProposal(r);\n      const {\n        message: e\n      } = (0, _utils.getInternalError)(\"EXPIRED\", `proposal id: ${r}`);\n      throw new Error(e);\n    }\n  }\n}\nclass cs extends _core.Store {\n  constructor(r, e) {\n    super(r, e, ie, G), this.core = r, this.logger = e;\n  }\n}\nclass ls extends _core.Store {\n  constructor(r, e) {\n    super(r, e, ne, G), this.core = r, this.logger = e;\n  }\n}\nclass ps extends _core.Store {\n  constructor(r, e) {\n    super(r, e, ae, G, s => s.id), this.core = r, this.logger = e;\n  }\n}\nclass U extends _types.ISignClient {\n  constructor(r) {\n    super(r), this.protocol = Y, this.version = J, this.name = $.name, this.events = new _events.EventEmitter(), this.on = (s, t) => this.events.on(s, t), this.once = (s, t) => this.events.once(s, t), this.off = (s, t) => this.events.off(s, t), this.removeListener = (s, t) => this.events.removeListener(s, t), this.removeAllListeners = s => this.events.removeAllListeners(s), this.connect = async s => {\n      try {\n        return await this.engine.connect(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.pair = async s => {\n      try {\n        return await this.engine.pair(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.approve = async s => {\n      try {\n        return await this.engine.approve(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.reject = async s => {\n      try {\n        return await this.engine.reject(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.update = async s => {\n      try {\n        return await this.engine.update(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.extend = async s => {\n      try {\n        return await this.engine.extend(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.request = async s => {\n      try {\n        return await this.engine.request(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.respond = async s => {\n      try {\n        return await this.engine.respond(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.ping = async s => {\n      try {\n        return await this.engine.ping(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.emit = async s => {\n      try {\n        return await this.engine.emit(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.disconnect = async s => {\n      try {\n        return await this.engine.disconnect(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.find = s => {\n      try {\n        return this.engine.find(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.getPendingSessionRequests = () => {\n      try {\n        return this.engine.getPendingSessionRequests();\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.name = r?.name || $.name, this.metadata = r?.metadata || (0, _utils.getAppMetadata)();\n    const e = typeof r?.logger < \"u\" && typeof r?.logger != \"string\" ? r.logger : (0, _logger.pino)((0, _logger.getDefaultLoggerOptions)({\n      level: r?.logger || $.logger\n    }));\n    this.core = r?.core || new _core.Core(r), this.logger = (0, _logger.generateChildLogger)(e, this.name), this.session = new ls(this.core, this.logger), this.proposal = new cs(this.core, this.logger), this.pendingRequest = new ps(this.core, this.logger), this.engine = new as(this);\n  }\n  static async init(r) {\n    const e = new U(r);\n    return await e.initialize(), e;\n  }\n  get context() {\n    return (0, _logger.getLoggerContext)(this.logger);\n  }\n  get pairing() {\n    return this.core.pairing.pairings;\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\");\n    try {\n      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({\n        verifyUrl: this.metadata.verifyUrl\n      }), this.logger.info(\"SignClient Initialization Success\");\n    } catch (r) {\n      throw this.logger.info(\"SignClient Initialization Failure\"), this.logger.error(r.message), r;\n    }\n  }\n}\nexports.default = U;\nconst hs = exports.SignClient = U;"},"sourceMaps":{"js":{"mappings":[],"sources":{},"lineCount":null}},"error":null,"hash":"7cf4793f37b590d636c693c79dbce501","cacheData":{"env":{}}}