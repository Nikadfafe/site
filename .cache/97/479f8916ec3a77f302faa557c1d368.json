{"id":"node_modules/@walletconnect/utils/dist/index.es.js","dependencies":[{"name":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/utils/dist/index.es.js.map","includedInParent":true,"mtime":1721502865758},{"name":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/package.json","includedInParent":true,"mtime":1721990127148},{"name":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/utils/package.json","includedInParent":true,"mtime":1721502865758},{"name":"@stablelib/chacha20poly1305","loc":{"line":1,"column":34,"index":34},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/utils/dist/index.es.js","resolved":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@stablelib/chacha20poly1305/lib/chacha20poly1305.js"},{"name":"@stablelib/hkdf","loc":{"line":1,"column":86,"index":86},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/utils/dist/index.es.js","resolved":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@stablelib/hkdf/lib/hkdf.js"},{"name":"@stablelib/random","loc":{"line":1,"column":133,"index":133},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/utils/dist/index.es.js","resolved":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@stablelib/random/lib/random.js"},{"name":"@stablelib/sha256","loc":{"line":1,"column":188,"index":188},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/utils/dist/index.es.js","resolved":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@stablelib/sha256/lib/sha256.js"},{"name":"@stablelib/x25519","loc":{"line":1,"column":225,"index":225},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/utils/dist/index.es.js","resolved":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@stablelib/x25519/lib/x25519.js"},{"name":"uint8arrays","loc":{"line":1,"column":299,"index":299},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/utils/dist/index.es.js","resolved":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/uint8arrays/cjs/src/index.js"},{"name":"detect-browser","loc":{"line":1,"column":337,"index":337},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/utils/dist/index.es.js","resolved":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/detect-browser/es/index.js"},{"name":"@walletconnect/time","loc":{"line":1,"column":425,"index":425},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/utils/dist/index.es.js","resolved":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/time/dist/cjs/index.js"},{"name":"@walletconnect/window-getters","loc":{"line":1,"column":513,"index":513},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/utils/dist/index.es.js","resolved":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/window-getters/dist/cjs/index.js"},{"name":"@walletconnect/window-metadata","loc":{"line":1,"column":580,"index":580},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/utils/dist/index.es.js","resolved":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/window-metadata/dist/cjs/index.js"},{"name":"query-string","loc":{"line":1,"column":629,"index":629},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/utils/dist/index.es.js","resolved":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/query-string/index.js"},{"name":"@walletconnect/relay-api","loc":{"line":1,"column":675,"index":675},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/utils/dist/index.es.js","resolved":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/relay-api/dist/esm/index.js"},{"name":"process","parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/utils/dist/index.es.js","resolved":"/Users/tamaz/.npm-global/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"generated":{"js":"var process = require(\"process\");\nvar global = arguments[3];\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UTF8 = exports.TYPE_1 = exports.TYPE_0 = exports.SLASH = exports.SDK_TYPE = exports.RELAYER_DEFAULT_PROTOCOL = exports.REACT_NATIVE_PRODUCT = exports.ONE_THOUSAND = exports.ENV_MAP = exports.EMPTY_SPACE = exports.DEFAULT_DEPTH = exports.COLON = exports.BASE64 = exports.BASE16 = exports.BASE10 = void 0;\nexports.appendToQueryString = Ce;\nexports.assertType = Wn;\nexports.buildApprovedNamespaces = It;\nexports.calcExpiry = ot;\nexports.capitalize = Zn;\nexports.capitalizeWord = Le;\nexports.createDelayedPromise = Xn;\nexports.createExpiringPromise = et;\nexports.decodeTypeByte = $;\nexports.decrypt = Cn;\nexports.deriveSymKey = Un;\nexports.deserialize = Z;\nexports.encodeTypeByte = Se;\nexports.encrypt = jn;\nexports.engineEvent = it;\nexports.enumify = void 0;\nexports.formatAccountId = he;\nexports.formatAccountWithChain = bn;\nexports.formatChainId = ye;\nexports.formatExpirerTarget = ne;\nexports.formatIdTarget = tt;\nexports.formatMessage = void 0;\nexports.formatMessageContext = zn;\nexports.formatRelayParams = We;\nexports.formatRelayRpcUrl = qn;\nexports.formatTopicTarget = nt;\nexports.formatUA = ke;\nexports.formatUri = yt;\nexports.generateKeyPair = Rn;\nexports.generateRandomBytes32 = An;\nexports.getAccountsChains = R;\nexports.getAccountsFromNamespaces = On;\nexports.getAddressFromAccount = Ee;\nexports.getAddressesFromAccounts = Nn;\nexports.getAppMetadata = Fn;\nexports.getChainFromAccount = ve;\nexports.getChainsFromAccounts = ge;\nexports.getChainsFromNamespace = M;\nexports.getChainsFromNamespaces = Sn;\nexports.getChainsFromRequiredNamespaces = In;\nexports.getDidChainId = exports.getDidAddressSegments = exports.getDidAddress = void 0;\nexports.getEnvironment = j;\nexports.getHttpUrl = Gn;\nexports.getInternalError = N;\nexports.getJavascriptID = Ve;\nexports.getJavascriptOS = De;\nexports.getLastItems = Ke;\nexports.getNamespacedDidChainId = void 0;\nexports.getNamespacesChains = Ye;\nexports.getNamespacesEventsForChainId = Qe;\nexports.getNamespacesMethodsForChainId = Je;\nexports.getRelayClientMetadata = Hn;\nexports.getRelayProtocolApi = ut;\nexports.getRelayProtocolName = at;\nexports.getRequiredNamespacesFromNamespaces = St;\nexports.getSdkError = A;\nexports.getUniqueValues = z;\nexports.handleDeeplinkRedirect = ct;\nexports.hasOverlap = O;\nexports.hashKey = _n;\nexports.hashMessage = $n;\nexports.isBrowser = je;\nexports.isCaipNamespace = te;\nexports.isConformingNamespaces = an;\nexports.isExpired = st;\nexports.isNode = ee;\nexports.isProposalStruct = At;\nexports.isReactNative = $e;\nexports.isSessionCompatible = wt;\nexports.isSessionStruct = Ut;\nexports.isTypeOneEnvelope = Vn;\nexports.isUndefined = I;\nexports.isValidAccountId = Xe;\nexports.isValidAccounts = tn;\nexports.isValidActions = on;\nexports.isValidArray = C;\nexports.isValidChainId = D;\nexports.isValidChains = en;\nexports.isValidController = _t;\nexports.isValidErrorReason = Vt;\nexports.isValidEvent = Kt;\nexports.isValidId = Ct;\nexports.isValidNamespaceAccounts = rn;\nexports.isValidNamespaceActions = se;\nexports.isValidNamespaceChains = nn;\nexports.isValidNamespaceMethodsOrEvents = oe;\nexports.isValidNamespaces = sn;\nexports.isValidNamespacesChainId = Lt;\nexports.isValidNamespacesEvent = Ft;\nexports.isValidNamespacesRequest = xt;\nexports.isValidNumber = q;\nexports.isValidObject = H;\nexports.isValidParams = Dt;\nexports.isValidRelay = cn;\nexports.isValidRelays = jt;\nexports.isValidRequest = kt;\nexports.isValidRequestExpiry = Gt;\nexports.isValidRequiredNamespaces = $t;\nexports.isValidResponse = Mt;\nexports.isValidString = y;\nexports.isValidUrl = Rt;\nexports.mapEntries = Jn;\nexports.mapToObj = Bn;\nexports.mergeArrays = S;\nexports.normalizeNamespaces = re;\nexports.objToMap = Yn;\nexports.parseAccountId = W;\nexports.parseChainId = me;\nexports.parseContextNames = Me;\nexports.parseExpirerTarget = rt;\nexports.parseNamespaceKey = Ze;\nexports.parseRelayParams = qe;\nexports.parseTopic = Ge;\nexports.parseUri = mt;\nexports.serialize = Ie;\nexports.validateDecoding = Dn;\nexports.validateEncoding = Pe;\nvar _chacha20poly = require(\"@stablelib/chacha20poly1305\");\nvar _hkdf = require(\"@stablelib/hkdf\");\nvar _random = require(\"@stablelib/random\");\nvar _sha = require(\"@stablelib/sha256\");\nvar ue = _interopRequireWildcard(require(\"@stablelib/x25519\"));\nvar _uint8arrays = require(\"uint8arrays\");\nvar _detectBrowser = require(\"detect-browser\");\nvar _time = require(\"@walletconnect/time\");\nvar _windowGetters = require(\"@walletconnect/window-getters\");\nvar _windowMetadata = require(\"@walletconnect/window-metadata\");\nvar V = _interopRequireWildcard(require(\"query-string\"));\nvar _relayApi = require(\"@walletconnect/relay-api\");\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\nconst k = \":\";\nfunction me(e) {\n  const [n, t] = e.split(k);\n  return {\n    namespace: n,\n    reference: t\n  };\n}\nfunction ye(e) {\n  const {\n    namespace: n,\n    reference: t\n  } = e;\n  return [n, t].join(k);\n}\nfunction W(e) {\n  const [n, t, r] = e.split(k);\n  return {\n    namespace: n,\n    reference: t,\n    address: r\n  };\n}\nfunction he(e) {\n  const {\n    namespace: n,\n    reference: t,\n    address: r\n  } = e;\n  return [n, t, r].join(k);\n}\nfunction z(e, n) {\n  const t = [];\n  return e.forEach(r => {\n    const o = n(r);\n    t.includes(o) || t.push(o);\n  }), t;\n}\nfunction Ee(e) {\n  const {\n    address: n\n  } = W(e);\n  return n;\n}\nfunction ve(e) {\n  const {\n    namespace: n,\n    reference: t\n  } = W(e);\n  return ye({\n    namespace: n,\n    reference: t\n  });\n}\nfunction bn(e, n) {\n  const {\n    namespace: t,\n    reference: r\n  } = me(n);\n  return he({\n    namespace: t,\n    reference: r,\n    address: e\n  });\n}\nfunction Nn(e) {\n  return z(e, Ee);\n}\nfunction ge(e) {\n  return z(e, ve);\n}\nfunction On(e, n = []) {\n  const t = [];\n  return Object.keys(e).forEach(r => {\n    if (n.length && !n.includes(r)) return;\n    const o = e[r];\n    t.push(...o.accounts);\n  }), t;\n}\nfunction Sn(e, n = []) {\n  const t = [];\n  return Object.keys(e).forEach(r => {\n    if (n.length && !n.includes(r)) return;\n    const o = e[r];\n    t.push(...ge(o.accounts));\n  }), t;\n}\nfunction In(e, n = []) {\n  const t = [];\n  return Object.keys(e).forEach(r => {\n    if (n.length && !n.includes(r)) return;\n    const o = e[r];\n    t.push(...M(r, o));\n  }), t;\n}\nfunction M(e, n) {\n  return e.includes(\":\") ? [e] : n.chains || [];\n}\nconst K = e => e?.split(\":\"),\n  be = e => {\n    const n = e && K(e);\n    if (n) return n[3];\n  },\n  Pn = e => {\n    const n = e && K(e);\n    if (n) return n[2] + \":\" + n[3];\n  },\n  Ne = e => {\n    const n = e && K(e);\n    if (n) return n.pop();\n  },\n  Tn = (e, n) => {\n    const t = `${e.domain} wants you to sign in with your Ethereum account:`,\n      r = Ne(n),\n      o = e.statement,\n      s = `URI: ${e.aud}`,\n      i = `Version: ${e.version}`,\n      d = `Chain ID: ${be(n)}`,\n      l = `Nonce: ${e.nonce}`,\n      c = `Issued At: ${e.iat}`,\n      u = e.resources && e.resources.length > 0 ? `Resources:\n${e.resources.map(a => `- ${a}`).join(`\n`)}` : void 0;\n    return [t, r, \"\", o, \"\", s, i, d, l, c, u].filter(a => a != null).join(`\n`);\n  },\n  B = exports.BASE10 = \"base10\",\n  p = exports.BASE16 = \"base16\",\n  L = exports.BASE64 = \"base64pad\",\n  x = exports.UTF8 = \"utf8\",\n  Y = exports.TYPE_0 = 0,\n  U = exports.TYPE_1 = 1,\n  wn = 0,\n  Oe = 1,\n  J = 12,\n  Q = 32;\nexports.formatMessage = Tn;\nexports.getDidAddress = Ne;\nexports.getNamespacedDidChainId = Pn;\nexports.getDidChainId = be;\nexports.getDidAddressSegments = K;\nfunction Rn() {\n  const e = ue.generateKeyPair();\n  return {\n    privateKey: (0, _uint8arrays.toString)(e.secretKey, p),\n    publicKey: (0, _uint8arrays.toString)(e.publicKey, p)\n  };\n}\nfunction An() {\n  const e = (0, _random.randomBytes)(Q);\n  return (0, _uint8arrays.toString)(e, p);\n}\nfunction Un(e, n) {\n  const t = ue.sharedKey((0, _uint8arrays.fromString)(e, p), (0, _uint8arrays.fromString)(n, p)),\n    r = new _hkdf.HKDF(_sha.SHA256, t).expand(Q);\n  return (0, _uint8arrays.toString)(r, p);\n}\nfunction _n(e) {\n  const n = (0, _sha.hash)((0, _uint8arrays.fromString)(e, p));\n  return (0, _uint8arrays.toString)(n, p);\n}\nfunction $n(e) {\n  const n = (0, _sha.hash)((0, _uint8arrays.fromString)(e, x));\n  return (0, _uint8arrays.toString)(n, p);\n}\nfunction Se(e) {\n  return (0, _uint8arrays.fromString)(`${e}`, B);\n}\nfunction $(e) {\n  return Number((0, _uint8arrays.toString)(e, B));\n}\nfunction jn(e) {\n  const n = Se(typeof e.type < \"u\" ? e.type : Y);\n  if ($(n) === U && typeof e.senderPublicKey > \"u\") throw new Error(\"Missing sender public key for type 1 envelope\");\n  const t = typeof e.senderPublicKey < \"u\" ? (0, _uint8arrays.fromString)(e.senderPublicKey, p) : void 0,\n    r = typeof e.iv < \"u\" ? (0, _uint8arrays.fromString)(e.iv, p) : (0, _random.randomBytes)(J),\n    o = new _chacha20poly.ChaCha20Poly1305((0, _uint8arrays.fromString)(e.symKey, p)).seal(r, (0, _uint8arrays.fromString)(e.message, x));\n  return Ie({\n    type: n,\n    sealed: o,\n    iv: r,\n    senderPublicKey: t\n  });\n}\nfunction Cn(e) {\n  const n = new _chacha20poly.ChaCha20Poly1305((0, _uint8arrays.fromString)(e.symKey, p)),\n    {\n      sealed: t,\n      iv: r\n    } = Z(e.encoded),\n    o = n.open(r, t);\n  if (o === null) throw new Error(\"Failed to decrypt\");\n  return (0, _uint8arrays.toString)(o, x);\n}\nfunction Ie(e) {\n  if ($(e.type) === U) {\n    if (typeof e.senderPublicKey > \"u\") throw new Error(\"Missing sender public key for type 1 envelope\");\n    return (0, _uint8arrays.toString)((0, _uint8arrays.concat)([e.type, e.senderPublicKey, e.iv, e.sealed]), L);\n  }\n  return (0, _uint8arrays.toString)((0, _uint8arrays.concat)([e.type, e.iv, e.sealed]), L);\n}\nfunction Z(e) {\n  const n = (0, _uint8arrays.fromString)(e, L),\n    t = n.slice(wn, Oe),\n    r = Oe;\n  if ($(t) === U) {\n    const d = r + Q,\n      l = d + J,\n      c = n.slice(r, d),\n      u = n.slice(d, l),\n      a = n.slice(l);\n    return {\n      type: t,\n      sealed: a,\n      iv: u,\n      senderPublicKey: c\n    };\n  }\n  const o = r + J,\n    s = n.slice(r, o),\n    i = n.slice(o);\n  return {\n    type: t,\n    sealed: i,\n    iv: s\n  };\n}\nfunction Dn(e, n) {\n  const t = Z(e);\n  return Pe({\n    type: $(t.type),\n    senderPublicKey: typeof t.senderPublicKey < \"u\" ? (0, _uint8arrays.toString)(t.senderPublicKey, p) : void 0,\n    receiverPublicKey: n?.receiverPublicKey\n  });\n}\nfunction Pe(e) {\n  const n = e?.type || Y;\n  if (n === U) {\n    if (typeof e?.senderPublicKey > \"u\") throw new Error(\"missing sender public key\");\n    if (typeof e?.receiverPublicKey > \"u\") throw new Error(\"missing receiver public key\");\n  }\n  return {\n    type: n,\n    senderPublicKey: e?.senderPublicKey,\n    receiverPublicKey: e?.receiverPublicKey\n  };\n}\nfunction Vn(e) {\n  return e.type === U && typeof e.senderPublicKey == \"string\" && typeof e.receiverPublicKey == \"string\";\n}\nvar kn = Object.defineProperty,\n  Te = Object.getOwnPropertySymbols,\n  Mn = Object.prototype.hasOwnProperty,\n  Kn = Object.prototype.propertyIsEnumerable,\n  we = (e, n, t) => n in e ? kn(e, n, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : e[n] = t,\n  Re = (e, n) => {\n    for (var t in n || (n = {})) Mn.call(n, t) && we(e, t, n[t]);\n    if (Te) for (var t of Te(n)) Kn.call(n, t) && we(e, t, n[t]);\n    return e;\n  };\nconst Ae = exports.REACT_NATIVE_PRODUCT = \"ReactNative\",\n  b = exports.ENV_MAP = {\n    reactNative: \"react-native\",\n    node: \"node\",\n    browser: \"browser\",\n    unknown: \"unknown\"\n  },\n  F = exports.EMPTY_SPACE = \" \",\n  Ln = exports.COLON = \":\",\n  Ue = exports.SLASH = \"/\",\n  X = exports.DEFAULT_DEPTH = 2,\n  xn = exports.ONE_THOUSAND = 1e3,\n  _e = exports.SDK_TYPE = \"js\";\nfunction ee() {\n  return typeof process < \"u\" && typeof process.versions < \"u\" && typeof process.versions.node < \"u\";\n}\nfunction $e() {\n  return !(0, _windowGetters.getDocument)() && !!(0, _windowGetters.getNavigator)() && navigator.product === Ae;\n}\nfunction je() {\n  return !ee() && !!(0, _windowGetters.getNavigator)();\n}\nfunction j() {\n  return $e() ? b.reactNative : ee() ? b.node : je() ? b.browser : b.unknown;\n}\nfunction Ce(e, n) {\n  let t = V.parse(e);\n  return t = Re(Re({}, t), n), e = V.stringify(t), e;\n}\nfunction Fn() {\n  return (0, _windowMetadata.getWindowMetadata)() || {\n    name: \"\",\n    description: \"\",\n    url: \"\",\n    icons: [\"\"]\n  };\n}\nfunction Hn(e, n) {\n  var t;\n  const r = j(),\n    o = {\n      protocol: e,\n      version: n,\n      env: r\n    };\n  return r === \"browser\" && (o.host = ((t = (0, _windowGetters.getLocation)()) == null ? void 0 : t.host) || \"unknown\"), o;\n}\nfunction De() {\n  if (j() === b.reactNative && typeof global < \"u\" && typeof (global == null ? void 0 : global.Platform) < \"u\") {\n    const {\n      OS: t,\n      Version: r\n    } = global.Platform;\n    return [t, r].join(\"-\");\n  }\n  const e = (0, _detectBrowser.detect)();\n  if (e === null) return \"unknown\";\n  const n = e.os ? e.os.replace(\" \", \"\").toLowerCase() : \"unknown\";\n  return e.type === \"browser\" ? [n, e.name, e.version].join(\"-\") : [n, e.version].join(\"-\");\n}\nfunction Ve() {\n  var e;\n  const n = j();\n  return n === b.browser ? [n, ((e = (0, _windowGetters.getLocation)()) == null ? void 0 : e.host) || \"unknown\"].join(\":\") : n;\n}\nfunction ke(e, n, t) {\n  const r = De(),\n    o = Ve();\n  return [[e, n].join(\"-\"), [_e, t].join(\"-\"), r, o].join(\"/\");\n}\nfunction qn({\n  protocol: e,\n  version: n,\n  relayUrl: t,\n  sdkVersion: r,\n  auth: o,\n  projectId: s,\n  useOnCloseEvent: i\n}) {\n  const d = t.split(\"?\"),\n    l = ke(e, n, r),\n    c = {\n      auth: o,\n      ua: l,\n      projectId: s,\n      useOnCloseEvent: i || void 0\n    },\n    u = Ce(d[1] || \"\", c);\n  return d[0] + \"?\" + u;\n}\nfunction Gn(e) {\n  let n = (e.match(/^[^:]+(?=:\\/\\/)/gi) || [])[0];\n  const t = typeof n < \"u\" ? e.split(\"://\")[1] : e;\n  return n = n === \"wss\" ? \"https\" : \"http\", [n, t].join(\"://\");\n}\nfunction Wn(e, n, t) {\n  if (!e[n] || typeof e[n] !== t) throw new Error(`Missing or invalid \"${n}\" param`);\n}\nfunction Me(e, n = X) {\n  return Ke(e.split(Ue), n);\n}\nfunction zn(e) {\n  return Me(e).join(F);\n}\nfunction O(e, n) {\n  return e.filter(t => n.includes(t)).length === e.length;\n}\nfunction Ke(e, n = X) {\n  return e.slice(Math.max(e.length - n, 0));\n}\nfunction Bn(e) {\n  return Object.fromEntries(e.entries());\n}\nfunction Yn(e) {\n  return new Map(Object.entries(e));\n}\nfunction Jn(e, n) {\n  const t = {};\n  return Object.keys(e).forEach(r => {\n    t[r] = n(e[r]);\n  }), t;\n}\nconst Qn = e => e;\nexports.enumify = Qn;\nfunction Le(e) {\n  return e.trim().replace(/^\\w/, n => n.toUpperCase());\n}\nfunction Zn(e) {\n  return e.split(F).map(n => Le(n)).join(F);\n}\nfunction Xn(e = _time.FIVE_MINUTES, n) {\n  const t = (0, _time.toMiliseconds)(e || _time.FIVE_MINUTES);\n  let r, o, s;\n  return {\n    resolve: i => {\n      s && r && (clearTimeout(s), r(i));\n    },\n    reject: i => {\n      s && o && (clearTimeout(s), o(i));\n    },\n    done: () => new Promise((i, d) => {\n      s = setTimeout(() => {\n        d(new Error(n));\n      }, t), r = i, o = d;\n    })\n  };\n}\nfunction et(e, n, t) {\n  return new Promise(async (r, o) => {\n    const s = setTimeout(() => o(new Error(t)), n);\n    try {\n      const i = await e;\n      r(i);\n    } catch (i) {\n      o(i);\n    }\n    clearTimeout(s);\n  });\n}\nfunction ne(e, n) {\n  if (typeof n == \"string\" && n.startsWith(`${e}:`)) return n;\n  if (e.toLowerCase() === \"topic\") {\n    if (typeof n != \"string\") throw new Error('Value must be \"string\" for expirer target type: topic');\n    return `topic:${n}`;\n  } else if (e.toLowerCase() === \"id\") {\n    if (typeof n != \"number\") throw new Error('Value must be \"number\" for expirer target type: id');\n    return `id:${n}`;\n  }\n  throw new Error(`Unknown expirer target type: ${e}`);\n}\nfunction nt(e) {\n  return ne(\"topic\", e);\n}\nfunction tt(e) {\n  return ne(\"id\", e);\n}\nfunction rt(e) {\n  const [n, t] = e.split(\":\"),\n    r = {\n      id: void 0,\n      topic: void 0\n    };\n  if (n === \"topic\" && typeof t == \"string\") r.topic = t;else if (n === \"id\" && Number.isInteger(Number(t))) r.id = Number(t);else throw new Error(`Invalid target, expected id:number or topic:string, got ${n}:${t}`);\n  return r;\n}\nfunction ot(e, n) {\n  return (0, _time.fromMiliseconds)((n || Date.now()) + (0, _time.toMiliseconds)(e));\n}\nfunction st(e) {\n  return Date.now() >= (0, _time.toMiliseconds)(e);\n}\nfunction it(e, n) {\n  return `${e}${n ? `:${n}` : \"\"}`;\n}\nfunction S(e = [], n = []) {\n  return [...new Set([...e, ...n])];\n}\nasync function ct({\n  id: e,\n  topic: n,\n  wcDeepLink: t\n}) {\n  try {\n    if (!t) return;\n    const r = typeof t == \"string\" ? JSON.parse(t) : t;\n    let o = r?.href;\n    if (typeof o != \"string\") return;\n    o.endsWith(\"/\") && (o = o.slice(0, -1));\n    const s = `${o}/wc?requestId=${e}&sessionTopic=${n}`,\n      i = j();\n    i === b.browser ? s.startsWith(\"https://\") ? window.open(s, \"_blank\", \"noreferrer noopener\") : window.open(s, \"_self\", \"noreferrer noopener\") : i === b.reactNative && typeof (global == null ? void 0 : global.Linking) < \"u\" && (await global.Linking.openURL(s));\n  } catch (r) {\n    console.error(r);\n  }\n}\nconst xe = exports.RELAYER_DEFAULT_PROTOCOL = \"irn\";\nfunction at(e) {\n  return e?.relay || {\n    protocol: xe\n  };\n}\nfunction ut(e) {\n  const n = _relayApi.RELAY_JSONRPC[e];\n  if (typeof n > \"u\") throw new Error(`Relay Protocol not supported: ${e}`);\n  return n;\n}\nvar dt = Object.defineProperty,\n  Fe = Object.getOwnPropertySymbols,\n  lt = Object.prototype.hasOwnProperty,\n  ft = Object.prototype.propertyIsEnumerable,\n  He = (e, n, t) => n in e ? dt(e, n, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : e[n] = t,\n  pt = (e, n) => {\n    for (var t in n || (n = {})) lt.call(n, t) && He(e, t, n[t]);\n    if (Fe) for (var t of Fe(n)) ft.call(n, t) && He(e, t, n[t]);\n    return e;\n  };\nfunction qe(e, n = \"-\") {\n  const t = {},\n    r = \"relay\" + n;\n  return Object.keys(e).forEach(o => {\n    if (o.startsWith(r)) {\n      const s = o.replace(r, \"\"),\n        i = e[o];\n      t[s] = i;\n    }\n  }), t;\n}\nfunction mt(e) {\n  const n = e.indexOf(\":\"),\n    t = e.indexOf(\"?\") !== -1 ? e.indexOf(\"?\") : void 0,\n    r = e.substring(0, n),\n    o = e.substring(n + 1, t).split(\"@\"),\n    s = typeof t < \"u\" ? e.substring(t) : \"\",\n    i = V.parse(s);\n  return {\n    protocol: r,\n    topic: Ge(o[0]),\n    version: parseInt(o[1], 10),\n    symKey: i.symKey,\n    relay: qe(i)\n  };\n}\nfunction Ge(e) {\n  return e.startsWith(\"//\") ? e.substring(2) : e;\n}\nfunction We(e, n = \"-\") {\n  const t = \"relay\",\n    r = {};\n  return Object.keys(e).forEach(o => {\n    const s = t + n + o;\n    e[o] && (r[s] = e[o]);\n  }), r;\n}\nfunction yt(e) {\n  return `${e.protocol}:${e.topic}@${e.version}?` + V.stringify(pt({\n    symKey: e.symKey\n  }, We(e.relay)));\n}\nvar ht = Object.defineProperty,\n  Et = Object.defineProperties,\n  vt = Object.getOwnPropertyDescriptors,\n  ze = Object.getOwnPropertySymbols,\n  gt = Object.prototype.hasOwnProperty,\n  bt = Object.prototype.propertyIsEnumerable,\n  Be = (e, n, t) => n in e ? ht(e, n, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : e[n] = t,\n  Nt = (e, n) => {\n    for (var t in n || (n = {})) gt.call(n, t) && Be(e, t, n[t]);\n    if (ze) for (var t of ze(n)) bt.call(n, t) && Be(e, t, n[t]);\n    return e;\n  },\n  Ot = (e, n) => Et(e, vt(n));\nfunction R(e) {\n  const n = [];\n  return e.forEach(t => {\n    const [r, o] = t.split(\":\");\n    n.push(`${r}:${o}`);\n  }), n;\n}\nfunction Ye(e) {\n  const n = [];\n  return Object.values(e).forEach(t => {\n    n.push(...R(t.accounts));\n  }), n;\n}\nfunction Je(e, n) {\n  const t = [];\n  return Object.values(e).forEach(r => {\n    R(r.accounts).includes(n) && t.push(...r.methods);\n  }), t;\n}\nfunction Qe(e, n) {\n  const t = [];\n  return Object.values(e).forEach(r => {\n    R(r.accounts).includes(n) && t.push(...r.events);\n  }), t;\n}\nfunction St(e, n) {\n  const t = sn(e, n);\n  if (t) throw new Error(t.message);\n  const r = {};\n  for (const [o, s] of Object.entries(e)) r[o] = {\n    methods: s.methods,\n    events: s.events,\n    chains: s.accounts.map(i => `${i.split(\":\")[0]}:${i.split(\":\")[1]}`)\n  };\n  return r;\n}\nfunction It(e) {\n  const {\n      proposal: {\n        requiredNamespaces: n,\n        optionalNamespaces: t = {}\n      },\n      supportedNamespaces: r\n    } = e,\n    o = re(n),\n    s = re(t),\n    i = {};\n  Object.keys(r).forEach(c => {\n    const u = r[c].chains,\n      a = r[c].methods,\n      g = r[c].events,\n      P = r[c].accounts;\n    u.forEach(m => {\n      if (!P.some(f => f.includes(m))) throw new Error(`No accounts provided for chain ${m} in namespace ${c}`);\n    }), i[c] = {\n      chains: u,\n      methods: a,\n      events: g,\n      accounts: P\n    };\n  });\n  const d = an(n, i, \"approve()\");\n  if (d) throw new Error(d.message);\n  const l = {};\n  return !Object.keys(n).length && !Object.keys(t).length ? i : (Object.keys(o).forEach(c => {\n    const u = r[c].chains.filter(m => {\n        var f, h;\n        return (h = (f = o[c]) == null ? void 0 : f.chains) == null ? void 0 : h.includes(m);\n      }),\n      a = r[c].methods.filter(m => {\n        var f, h;\n        return (h = (f = o[c]) == null ? void 0 : f.methods) == null ? void 0 : h.includes(m);\n      }),\n      g = r[c].events.filter(m => {\n        var f, h;\n        return (h = (f = o[c]) == null ? void 0 : f.events) == null ? void 0 : h.includes(m);\n      }),\n      P = u.map(m => r[c].accounts.filter(f => f.includes(`${m}:`))).flat();\n    l[c] = {\n      chains: u,\n      methods: a,\n      events: g,\n      accounts: P\n    };\n  }), Object.keys(s).forEach(c => {\n    var u, a, g, P, m, f;\n    if (!r[c]) return;\n    const h = (a = (u = s[c]) == null ? void 0 : u.chains) == null ? void 0 : a.filter(T => r[c].chains.includes(T)),\n      dn = r[c].methods.filter(T => {\n        var w, _;\n        return (_ = (w = s[c]) == null ? void 0 : w.methods) == null ? void 0 : _.includes(T);\n      }),\n      ln = r[c].events.filter(T => {\n        var w, _;\n        return (_ = (w = s[c]) == null ? void 0 : w.events) == null ? void 0 : _.includes(T);\n      }),\n      fn = h?.map(T => r[c].accounts.filter(w => w.includes(T))).flat();\n    l[c] = {\n      chains: S((g = l[c]) == null ? void 0 : g.chains, h),\n      methods: S((P = l[c]) == null ? void 0 : P.methods, dn),\n      events: S((m = l[c]) == null ? void 0 : m.events, ln),\n      accounts: S((f = l[c]) == null ? void 0 : f.accounts, fn)\n    };\n  }), l);\n}\nfunction te(e) {\n  return e.includes(\":\");\n}\nfunction Ze(e) {\n  return te(e) ? e.split(\":\")[0] : e;\n}\nfunction re(e) {\n  var n, t, r;\n  const o = {};\n  if (!H(e)) return o;\n  for (const [s, i] of Object.entries(e)) {\n    const d = te(s) ? [s] : i.chains,\n      l = i.methods || [],\n      c = i.events || [],\n      u = Ze(s);\n    o[u] = Ot(Nt({}, o[u]), {\n      chains: S(d, (n = o[u]) == null ? void 0 : n.chains),\n      methods: S(l, (t = o[u]) == null ? void 0 : t.methods),\n      events: S(c, (r = o[u]) == null ? void 0 : r.events)\n    });\n  }\n  return o;\n}\nconst Pt = {\n    INVALID_METHOD: {\n      message: \"Invalid method.\",\n      code: 1001\n    },\n    INVALID_EVENT: {\n      message: \"Invalid event.\",\n      code: 1002\n    },\n    INVALID_UPDATE_REQUEST: {\n      message: \"Invalid update request.\",\n      code: 1003\n    },\n    INVALID_EXTEND_REQUEST: {\n      message: \"Invalid extend request.\",\n      code: 1004\n    },\n    INVALID_SESSION_SETTLE_REQUEST: {\n      message: \"Invalid session settle request.\",\n      code: 1005\n    },\n    UNAUTHORIZED_METHOD: {\n      message: \"Unauthorized method.\",\n      code: 3001\n    },\n    UNAUTHORIZED_EVENT: {\n      message: \"Unauthorized event.\",\n      code: 3002\n    },\n    UNAUTHORIZED_UPDATE_REQUEST: {\n      message: \"Unauthorized update request.\",\n      code: 3003\n    },\n    UNAUTHORIZED_EXTEND_REQUEST: {\n      message: \"Unauthorized extend request.\",\n      code: 3004\n    },\n    USER_REJECTED: {\n      message: \"User rejected.\",\n      code: 5e3\n    },\n    USER_REJECTED_CHAINS: {\n      message: \"User rejected chains.\",\n      code: 5001\n    },\n    USER_REJECTED_METHODS: {\n      message: \"User rejected methods.\",\n      code: 5002\n    },\n    USER_REJECTED_EVENTS: {\n      message: \"User rejected events.\",\n      code: 5003\n    },\n    UNSUPPORTED_CHAINS: {\n      message: \"Unsupported chains.\",\n      code: 5100\n    },\n    UNSUPPORTED_METHODS: {\n      message: \"Unsupported methods.\",\n      code: 5101\n    },\n    UNSUPPORTED_EVENTS: {\n      message: \"Unsupported events.\",\n      code: 5102\n    },\n    UNSUPPORTED_ACCOUNTS: {\n      message: \"Unsupported accounts.\",\n      code: 5103\n    },\n    UNSUPPORTED_NAMESPACE_KEY: {\n      message: \"Unsupported namespace key.\",\n      code: 5104\n    },\n    USER_DISCONNECTED: {\n      message: \"User disconnected.\",\n      code: 6e3\n    },\n    SESSION_SETTLEMENT_FAILED: {\n      message: \"Session settlement failed.\",\n      code: 7e3\n    },\n    WC_METHOD_UNSUPPORTED: {\n      message: \"Unsupported wc_ method.\",\n      code: 10001\n    }\n  },\n  Tt = {\n    NOT_INITIALIZED: {\n      message: \"Not initialized.\",\n      code: 1\n    },\n    NO_MATCHING_KEY: {\n      message: \"No matching key.\",\n      code: 2\n    },\n    RESTORE_WILL_OVERRIDE: {\n      message: \"Restore will override.\",\n      code: 3\n    },\n    RESUBSCRIBED: {\n      message: \"Resubscribed.\",\n      code: 4\n    },\n    MISSING_OR_INVALID: {\n      message: \"Missing or invalid.\",\n      code: 5\n    },\n    EXPIRED: {\n      message: \"Expired.\",\n      code: 6\n    },\n    UNKNOWN_TYPE: {\n      message: \"Unknown type.\",\n      code: 7\n    },\n    MISMATCHED_TOPIC: {\n      message: \"Mismatched topic.\",\n      code: 8\n    },\n    NON_CONFORMING_NAMESPACES: {\n      message: \"Non conforming namespaces.\",\n      code: 9\n    }\n  };\nfunction N(e, n) {\n  const {\n    message: t,\n    code: r\n  } = Tt[e];\n  return {\n    message: n ? `${t} ${n}` : t,\n    code: r\n  };\n}\nfunction A(e, n) {\n  const {\n    message: t,\n    code: r\n  } = Pt[e];\n  return {\n    message: n ? `${t} ${n}` : t,\n    code: r\n  };\n}\nfunction C(e, n) {\n  return Array.isArray(e) ? typeof n < \"u\" && e.length ? e.every(n) : !0 : !1;\n}\nfunction H(e) {\n  return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length;\n}\nfunction I(e) {\n  return typeof e > \"u\";\n}\nfunction y(e, n) {\n  return n && I(e) ? !0 : typeof e == \"string\" && !!e.trim().length;\n}\nfunction q(e, n) {\n  return n && I(e) ? !0 : typeof e == \"number\" && !isNaN(e);\n}\nfunction wt(e, n) {\n  const {\n      requiredNamespaces: t\n    } = n,\n    r = Object.keys(e.namespaces),\n    o = Object.keys(t);\n  let s = !0;\n  return O(o, r) ? (r.forEach(i => {\n    const {\n        accounts: d,\n        methods: l,\n        events: c\n      } = e.namespaces[i],\n      u = R(d),\n      a = t[i];\n    (!O(M(i, a), u) || !O(a.methods, l) || !O(a.events, c)) && (s = !1);\n  }), s) : !1;\n}\nfunction D(e) {\n  return y(e, !1) && e.includes(\":\") ? e.split(\":\").length === 2 : !1;\n}\nfunction Xe(e) {\n  if (y(e, !1) && e.includes(\":\")) {\n    const n = e.split(\":\");\n    if (n.length === 3) {\n      const t = n[0] + \":\" + n[1];\n      return !!n[2] && D(t);\n    }\n  }\n  return !1;\n}\nfunction Rt(e) {\n  if (y(e, !1)) try {\n    return typeof new URL(e) < \"u\";\n  } catch {\n    return !1;\n  }\n  return !1;\n}\nfunction At(e) {\n  var n;\n  return (n = e?.proposer) == null ? void 0 : n.publicKey;\n}\nfunction Ut(e) {\n  return e?.topic;\n}\nfunction _t(e, n) {\n  let t = null;\n  return y(e?.publicKey, !1) || (t = N(\"MISSING_OR_INVALID\", `${n} controller public key should be a string`)), t;\n}\nfunction oe(e) {\n  let n = !0;\n  return C(e) ? e.length && (n = e.every(t => y(t, !1))) : n = !1, n;\n}\nfunction en(e, n, t) {\n  let r = null;\n  return C(n) && n.length ? n.forEach(o => {\n    r || D(o) || (r = A(\"UNSUPPORTED_CHAINS\", `${t}, chain ${o} should be a string and conform to \"namespace:chainId\" format`));\n  }) : D(e) || (r = A(\"UNSUPPORTED_CHAINS\", `${t}, chains must be defined as \"namespace:chainId\" e.g. \"eip155:1\": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: [\"eip155:1\", \"eip155:5\"] }`)), r;\n}\nfunction nn(e, n, t) {\n  let r = null;\n  return Object.entries(e).forEach(([o, s]) => {\n    if (r) return;\n    const i = en(o, M(o, s), `${n} ${t}`);\n    i && (r = i);\n  }), r;\n}\nfunction tn(e, n) {\n  let t = null;\n  return C(e) ? e.forEach(r => {\n    t || Xe(r) || (t = A(\"UNSUPPORTED_ACCOUNTS\", `${n}, account ${r} should be a string and conform to \"namespace:chainId:address\" format`));\n  }) : t = A(\"UNSUPPORTED_ACCOUNTS\", `${n}, accounts should be an array of strings conforming to \"namespace:chainId:address\" format`), t;\n}\nfunction rn(e, n) {\n  let t = null;\n  return Object.values(e).forEach(r => {\n    if (t) return;\n    const o = tn(r?.accounts, `${n} namespace`);\n    o && (t = o);\n  }), t;\n}\nfunction on(e, n) {\n  let t = null;\n  return oe(e?.methods) ? oe(e?.events) || (t = A(\"UNSUPPORTED_EVENTS\", `${n}, events should be an array of strings or empty array for no events`)) : t = A(\"UNSUPPORTED_METHODS\", `${n}, methods should be an array of strings or empty array for no methods`), t;\n}\nfunction se(e, n) {\n  let t = null;\n  return Object.values(e).forEach(r => {\n    if (t) return;\n    const o = on(r, `${n}, namespace`);\n    o && (t = o);\n  }), t;\n}\nfunction $t(e, n, t) {\n  let r = null;\n  if (e && H(e)) {\n    const o = se(e, n);\n    o && (r = o);\n    const s = nn(e, n, t);\n    s && (r = s);\n  } else r = N(\"MISSING_OR_INVALID\", `${n}, ${t} should be an object with data`);\n  return r;\n}\nfunction sn(e, n) {\n  let t = null;\n  if (e && H(e)) {\n    const r = se(e, n);\n    r && (t = r);\n    const o = rn(e, n);\n    o && (t = o);\n  } else t = N(\"MISSING_OR_INVALID\", `${n}, namespaces should be an object with data`);\n  return t;\n}\nfunction cn(e) {\n  return y(e.protocol, !0);\n}\nfunction jt(e, n) {\n  let t = !1;\n  return n && !e ? t = !0 : e && C(e) && e.length && e.forEach(r => {\n    t = cn(r);\n  }), t;\n}\nfunction Ct(e) {\n  return typeof e == \"number\";\n}\nfunction Dt(e) {\n  return typeof e < \"u\" && typeof e !== null;\n}\nfunction Vt(e) {\n  return !(!e || typeof e != \"object\" || !e.code || !q(e.code, !1) || !e.message || !y(e.message, !1));\n}\nfunction kt(e) {\n  return !(I(e) || !y(e.method, !1));\n}\nfunction Mt(e) {\n  return !(I(e) || I(e.result) && I(e.error) || !q(e.id, !1) || !y(e.jsonrpc, !1));\n}\nfunction Kt(e) {\n  return !(I(e) || !y(e.name, !1));\n}\nfunction Lt(e, n) {\n  return !(!D(n) || !Ye(e).includes(n));\n}\nfunction xt(e, n, t) {\n  return y(t, !1) ? Je(e, n).includes(t) : !1;\n}\nfunction Ft(e, n, t) {\n  return y(t, !1) ? Qe(e, n).includes(t) : !1;\n}\nfunction an(e, n, t) {\n  let r = null;\n  const o = Ht(e),\n    s = qt(n),\n    i = Object.keys(o),\n    d = Object.keys(s),\n    l = un(Object.keys(e)),\n    c = un(Object.keys(n)),\n    u = l.filter(a => !c.includes(a));\n  return u.length && (r = N(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces keys don't satisfy requiredNamespaces.\n      Required: ${u.toString()}\n      Received: ${Object.keys(n).toString()}`)), O(i, d) || (r = N(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces chains don't satisfy required namespaces.\n      Required: ${i.toString()}\n      Approved: ${d.toString()}`)), Object.keys(n).forEach(a => {\n    if (!a.includes(\":\") || r) return;\n    const g = R(n[a].accounts);\n    g.includes(a) || (r = N(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces accounts don't satisfy namespace accounts for ${a}\n        Required: ${a}\n        Approved: ${g.toString()}`));\n  }), i.forEach(a => {\n    r || (O(o[a].methods, s[a].methods) ? O(o[a].events, s[a].events) || (r = N(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces events don't satisfy namespace events for ${a}`)) : r = N(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces methods don't satisfy namespace methods for ${a}`));\n  }), r;\n}\nfunction Ht(e) {\n  const n = {};\n  return Object.keys(e).forEach(t => {\n    var r;\n    t.includes(\":\") ? n[t] = e[t] : (r = e[t].chains) == null || r.forEach(o => {\n      n[o] = {\n        methods: e[t].methods,\n        events: e[t].events\n      };\n    });\n  }), n;\n}\nfunction un(e) {\n  return [...new Set(e.map(n => n.includes(\":\") ? n.split(\":\")[0] : n))];\n}\nfunction qt(e) {\n  const n = {};\n  return Object.keys(e).forEach(t => {\n    if (t.includes(\":\")) n[t] = e[t];else {\n      const r = R(e[t].accounts);\n      r?.forEach(o => {\n        n[o] = {\n          accounts: e[t].accounts.filter(s => s.includes(`${o}:`)),\n          methods: e[t].methods,\n          events: e[t].events\n        };\n      });\n    }\n  }), n;\n}\nfunction Gt(e, n) {\n  return q(e, !1) && e <= n.max && e >= n.min;\n}"},"sourceMaps":{"js":{"mappings":[],"sources":{},"lineCount":null}},"error":null,"hash":"61ee64943e3d109cdf51c958ad8014de","cacheData":{"env":{}}}