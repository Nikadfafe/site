{"id":"node_modules/@stablelib/hkdf/lib/hkdf.js","dependencies":[{"name":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@stablelib/hkdf/lib/hkdf.js.map","includedInParent":true,"mtime":1721477764393},{"name":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@stablelib/hkdf/hkdf.ts","includedInParent":true,"mtime":1721477764393},{"name":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/package.json","includedInParent":true,"mtime":1721990127148},{"name":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@stablelib/hkdf/package.json","includedInParent":true,"mtime":1721477764393},{"name":"@stablelib/hmac","loc":{"line":5,"column":21,"index":183},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@stablelib/hkdf/lib/hkdf.js","resolved":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@stablelib/hmac/lib/hmac.js"},{"name":"@stablelib/wipe","loc":{"line":6,"column":21,"index":224},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@stablelib/hkdf/lib/hkdf.js","resolved":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@stablelib/wipe/lib/wipe.js"}],"generated":{"js":"\"use strict\";\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar hmac_1 = require(\"@stablelib/hmac\");\nvar wipe_1 = require(\"@stablelib/wipe\");\n/**\n * HMAC-based Extract-and-Expand Key Derivation Function.\n *\n * Implements HKDF from RFC5869.\n *\n * Expands the given master key with salt and info into\n * a limited stream of key material.\n */\nvar HKDF = /** @class */ (function () {\n    /**\n     * Create a new HKDF instance for the given hash function\n     * with the master key, optional salt, and info.\n     *\n     * - Master key is a high-entropy secret key (not a password).\n     * - Salt is a non-secret random value.\n     * - Info is application- and/or context-specific information.\n     */\n    function HKDF(hash, key, salt, info) {\n        if (salt === void 0) { salt = new Uint8Array(0); }\n        this._counter = new Uint8Array(1); // starts with zero\n        this._hash = hash;\n        this._info = info;\n        // HKDF-Extract uses salt as HMAC key, and key as data.\n        var okm = hmac_1.hmac(this._hash, salt, key);\n        // Initialize HMAC for expanding with extracted key.\n        this._hmac = new hmac_1.HMAC(hash, okm);\n        // Allocate buffer.\n        this._buffer = new Uint8Array(this._hmac.digestLength);\n        this._bufpos = this._buffer.length;\n    }\n    // Fill buffer with new block of HKDF-Extract output.\n    HKDF.prototype._fillBuffer = function () {\n        // Increment counter.\n        this._counter[0]++;\n        var ctr = this._counter[0];\n        // Check if counter overflowed.\n        if (ctr === 0) {\n            throw new Error(\"hkdf: cannot expand more\");\n        }\n        // Prepare HMAC instance for new data with old key.\n        this._hmac.reset();\n        // Hash in previous output if it was generated\n        // (i.e. counter is greater than 1).\n        if (ctr > 1) {\n            this._hmac.update(this._buffer);\n        }\n        // Hash in info if it exists.\n        if (this._info) {\n            this._hmac.update(this._info);\n        }\n        // Hash in the counter.\n        this._hmac.update(this._counter);\n        // Output result to buffer and clean HMAC instance.\n        this._hmac.finish(this._buffer);\n        // Reset buffer position.\n        this._bufpos = 0;\n    };\n    /**\n     * Expand returns next key material of the given length.\n     *\n     * It throws if expansion limit is reached (which is\n     * 254 digests of the underlying HMAC function).\n     */\n    HKDF.prototype.expand = function (length) {\n        var out = new Uint8Array(length);\n        for (var i = 0; i < out.length; i++) {\n            if (this._bufpos === this._buffer.length) {\n                this._fillBuffer();\n            }\n            out[i] = this._buffer[this._bufpos++];\n        }\n        return out;\n    };\n    HKDF.prototype.clean = function () {\n        this._hmac.clean();\n        wipe_1.wipe(this._buffer);\n        wipe_1.wipe(this._counter);\n        this._bufpos = 0;\n    };\n    return HKDF;\n}());\nexports.HKDF = HKDF;\n// TODO(dchest): maybe implement deriveKey?\n"},"sourceMaps":{"js":{"version":3,"file":"hkdf.js","sourceRoot":"","sources":["../hkdf.ts"],"names":[],"mappings":";AAAA,sCAAsC;AACtC,6CAA6C;;AAO7C,wCAA6C;AAC7C,wCAAuC;AAEvC;;;;;;;GAOG;AACH;IAQI;;;;;;;OAOG;IACH,cAAY,IAAoB,EAC5B,GAAe,EACf,IAAwB,EACxB,IAAiB;QADjB,qBAAA,EAAA,WAAW,UAAU,CAAC,CAAC,CAAC;QAdpB,aAAQ,GAAG,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,mBAAmB;QAiBrD,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QAClB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QAElB,uDAAuD;QACvD,IAAM,GAAG,GAAG,WAAI,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,EAAE,GAAG,CAAC,CAAC;QAExC,oDAAoD;QACpD,IAAI,CAAC,KAAK,GAAG,IAAI,WAAI,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;QAEjC,mBAAmB;QACnB,IAAI,CAAC,OAAO,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC;QACvD,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC;IACvC,CAAC;IAED,qDAAqD;IAC7C,0BAAW,GAAnB;QACI,qBAAqB;QACrB,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC;QAEnB,IAAM,GAAG,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;QAE7B,+BAA+B;QAC/B,IAAI,GAAG,KAAK,CAAC,EAAE;YACX,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAC;SAC/C;QAED,mDAAmD;QACnD,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;QAEnB,8CAA8C;QAC9C,oCAAoC;QACpC,IAAI,GAAG,GAAG,CAAC,EAAE;YACT,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;SACnC;QAED,6BAA6B;QAC7B,IAAI,IAAI,CAAC,KAAK,EAAE;YACZ,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SACjC;QAED,uBAAuB;QACvB,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAEjC,mDAAmD;QACnD,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QAEhC,yBAAyB;QACzB,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC;IACrB,CAAC;IAED;;;;;OAKG;IACH,qBAAM,GAAN,UAAO,MAAc;QACjB,IAAM,GAAG,GAAG,IAAI,UAAU,CAAC,MAAM,CAAC,CAAC;QACnC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACjC,IAAI,IAAI,CAAC,OAAO,KAAK,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE;gBACtC,IAAI,CAAC,WAAW,EAAE,CAAC;aACtB;YACD,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC;SACzC;QACD,OAAO,GAAG,CAAC;IACf,CAAC;IAED,oBAAK,GAAL;QACI,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;QACnB,WAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACnB,WAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QACpB,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC;IACrB,CAAC;IACL,WAAC;AAAD,CAAC,AA9FD,IA8FC;AA9FY,oBAAI;AAgGjB,2CAA2C","sourcesContent":["// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\n/**\n * Package hkdf implements HKDF key derivation function.\n */\n\nimport { Hash } from \"@stablelib/hash\";\nimport { HMAC, hmac } from \"@stablelib/hmac\";\nimport { wipe } from \"@stablelib/wipe\";\n\n/**\n * HMAC-based Extract-and-Expand Key Derivation Function.\n *\n * Implements HKDF from RFC5869.\n *\n * Expands the given master key with salt and info into\n * a limited stream of key material.\n */\nexport class HKDF {\n    private _hmac: HMAC;\n    private _buffer: Uint8Array;\n    private _bufpos: number;\n    private _counter = new Uint8Array(1); // starts with zero\n    private _hash: new () => Hash;\n    private _info?: Uint8Array;\n\n    /**\n     * Create a new HKDF instance for the given hash function\n     * with the master key, optional salt, and info.\n     *\n     * - Master key is a high-entropy secret key (not a password).\n     * - Salt is a non-secret random value.\n     * - Info is application- and/or context-specific information.\n     */\n    constructor(hash: new () => Hash,\n        key: Uint8Array,\n        salt = new Uint8Array(0),\n        info?: Uint8Array) {\n\n        this._hash = hash;\n        this._info = info;\n\n        // HKDF-Extract uses salt as HMAC key, and key as data.\n        const okm = hmac(this._hash, salt, key);\n\n        // Initialize HMAC for expanding with extracted key.\n        this._hmac = new HMAC(hash, okm);\n\n        // Allocate buffer.\n        this._buffer = new Uint8Array(this._hmac.digestLength);\n        this._bufpos = this._buffer.length;\n    }\n\n    // Fill buffer with new block of HKDF-Extract output.\n    private _fillBuffer(): void {\n        // Increment counter.\n        this._counter[0]++;\n\n        const ctr = this._counter[0];\n\n        // Check if counter overflowed.\n        if (ctr === 0) {\n            throw new Error(\"hkdf: cannot expand more\");\n        }\n\n        // Prepare HMAC instance for new data with old key.\n        this._hmac.reset();\n\n        // Hash in previous output if it was generated\n        // (i.e. counter is greater than 1).\n        if (ctr > 1) {\n            this._hmac.update(this._buffer);\n        }\n\n        // Hash in info if it exists.\n        if (this._info) {\n            this._hmac.update(this._info);\n        }\n\n        // Hash in the counter.\n        this._hmac.update(this._counter);\n\n        // Output result to buffer and clean HMAC instance.\n        this._hmac.finish(this._buffer);\n\n        // Reset buffer position.\n        this._bufpos = 0;\n    }\n\n    /**\n     * Expand returns next key material of the given length.\n     *\n     * It throws if expansion limit is reached (which is\n     * 254 digests of the underlying HMAC function).\n     */\n    expand(length: number): Uint8Array {\n        const out = new Uint8Array(length);\n        for (let i = 0; i < out.length; i++) {\n            if (this._bufpos === this._buffer.length) {\n                this._fillBuffer();\n            }\n            out[i] = this._buffer[this._bufpos++];\n        }\n        return out;\n    }\n\n    clean(): void {\n        this._hmac.clean();\n        wipe(this._buffer);\n        wipe(this._counter);\n        this._bufpos = 0;\n    }\n}\n\n// TODO(dchest): maybe implement deriveKey?\n"]}},"error":null,"hash":"d34e87c645fdcb91f838c669c5e257a6","cacheData":{"env":{}}}