{"id":"node_modules/@walletconnect/core/dist/index.es.js","dependencies":[{"name":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/core/dist/index.es.js.map","includedInParent":true,"mtime":1721502866330},{"name":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/package.json","includedInParent":true,"mtime":1721990127148},{"name":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/core/package.json","includedInParent":true,"mtime":1721502866330},{"name":"events","loc":{"line":1,"column":33,"index":33},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/core/dist/index.es.js","resolved":"/Users/tamaz/.npm-global/lib/node_modules/parcel-bundler/node_modules/events/events.js"},{"name":"@walletconnect/keyvaluestorage","loc":{"line":1,"column":56,"index":56},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/core/dist/index.es.js","resolved":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/keyvaluestorage/dist/cjs/browser/index.js"},{"name":"@walletconnect/heartbeat","loc":{"line":1,"column":138,"index":138},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/core/dist/index.es.js","resolved":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/heartbeat/dist/cjs/index.js"},{"name":"@walletconnect/logger","loc":{"line":1,"column":264,"index":264},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/core/dist/index.es.js","resolved":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/logger/dist/cjs/index.js"},{"name":"@walletconnect/types","loc":{"line":1,"column":447,"index":447},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/core/dist/index.es.js","resolved":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/types/dist/index.es.js"},{"name":"@walletconnect/safe-json","loc":{"line":1,"column":525,"index":525},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/core/dist/index.es.js","resolved":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/safe-json/dist/esm/index.js"},{"name":"@walletconnect/relay-auth","loc":{"line":1,"column":568,"index":568},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/core/dist/index.es.js","resolved":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/relay-auth/dist/esm/index.js"},{"name":"@walletconnect/utils","loc":{"line":1,"column":1408,"index":1408},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/core/dist/index.es.js","resolved":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/utils/dist/index.es.js"},{"name":"uint8arrays","loc":{"line":1,"column":1457,"index":1457},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/core/dist/index.es.js","resolved":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/uint8arrays/cjs/src/index.js"},{"name":"@walletconnect/time","loc":{"line":1,"column":1653,"index":1653},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/core/dist/index.es.js","resolved":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/time/dist/cjs/index.js"},{"name":"@walletconnect/jsonrpc-provider","loc":{"line":1,"column":1708,"index":1708},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/core/dist/index.es.js","resolved":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/jsonrpc-provider/dist/esm/index.js"},{"name":"@walletconnect/jsonrpc-utils","loc":{"line":1,"column":1942,"index":1942},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/core/dist/index.es.js","resolved":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js"},{"name":"@walletconnect/jsonrpc-ws-connection","loc":{"line":1,"column":1987,"index":1987},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/core/dist/index.es.js","resolved":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/jsonrpc-ws-connection/dist/esm/index.js"},{"name":"lodash.isequal","loc":{"line":1,"column":2040,"index":2040},"parent":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/@walletconnect/core/dist/index.es.js","resolved":"/Users/tamaz/Projects/Site/example/web-examples/dapps/ethereum-provider/node_modules/lodash.isequal/index.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.WALLETCONNECT_CLIENT_ID = exports.Verify = exports.VERIFY_SERVER = exports.VERIFY_CONTEXT = exports.Subscriber = exports.Store = exports.SUBSCRIBER_STORAGE_VERSION = exports.SUBSCRIBER_EVENTS = exports.SUBSCRIBER_DEFAULT_TTL = exports.SUBSCRIBER_CONTEXT = exports.STORE_STORAGE_VERSION = exports.Relayer = exports.RELAYER_TRANSPORT_CUTOFF = exports.RELAYER_SUBSCRIBER_SUFFIX = exports.RELAYER_STORAGE_OPTIONS = exports.RELAYER_SDK_VERSION = exports.RELAYER_RECONNECT_TIMEOUT = exports.RELAYER_PROVIDER_EVENTS = exports.RELAYER_FAILOVER_RELAY_URL = exports.RELAYER_EVENTS = exports.RELAYER_DEFAULT_RELAY_URL = exports.RELAYER_DEFAULT_PROTOCOL = exports.RELAYER_DEFAULT_LOGGER = exports.RELAYER_CONTEXT = exports.Pairing = exports.PUBLISHER_DEFAULT_TTL = exports.PUBLISHER_CONTEXT = exports.PENDING_SUB_RESOLUTION_TIMEOUT = exports.PAIRING_STORAGE_VERSION = exports.PAIRING_RPC_OPTS = exports.PAIRING_DEFAULT_TTL = exports.PAIRING_CONTEXT = exports.MessageTracker = exports.MESSAGES_STORAGE_VERSION = exports.MESSAGES_CONTEXT = exports.KeyChain = exports.KEYCHAIN_STORAGE_VERSION = exports.KEYCHAIN_CONTEXT = exports.JsonRpcHistory = exports.HISTORY_STORAGE_VERSION = exports.HISTORY_EVENTS = exports.HISTORY_CONTEXT = exports.Expirer = exports.EXPIRER_STORAGE_VERSION = exports.EXPIRER_EVENTS = exports.EXPIRER_DEFAULT_TTL = exports.EXPIRER_CONTEXT = exports.Crypto = exports.Core = exports.CRYPTO_JWT_TTL = exports.CRYPTO_CONTEXT = exports.CRYPTO_CLIENT_SEED = exports.CORE_VERSION = exports.CORE_STORAGE_PREFIX = exports.CORE_STORAGE_OPTIONS = exports.CORE_PROTOCOL = exports.CORE_DEFAULT = exports.CORE_CONTEXT = void 0;\nvar _events = _interopRequireWildcard(require(\"events\"));\nvar _keyvaluestorage = _interopRequireDefault(require(\"@walletconnect/keyvaluestorage\"));\nvar _heartbeat = require(\"@walletconnect/heartbeat\");\nvar _logger = require(\"@walletconnect/logger\");\nvar _types = require(\"@walletconnect/types\");\nvar _safeJson = require(\"@walletconnect/safe-json\");\nvar V = _interopRequireWildcard(require(\"@walletconnect/relay-auth\"));\nvar _utils = require(\"@walletconnect/utils\");\nvar _uint8arrays = require(\"uint8arrays\");\nvar _time = require(\"@walletconnect/time\");\nvar _jsonrpcProvider = require(\"@walletconnect/jsonrpc-provider\");\nvar _jsonrpcUtils = require(\"@walletconnect/jsonrpc-utils\");\nvar _jsonrpcWsConnection = _interopRequireDefault(require(\"@walletconnect/jsonrpc-ws-connection\"));\nvar _lodash = _interopRequireDefault(require(\"lodash.isequal\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\nfunction $i(r, e) {\n  if (r.length >= 255) throw new TypeError(\"Alphabet too long\");\n  for (var t = new Uint8Array(256), i = 0; i < t.length; i++) t[i] = 255;\n  for (var s = 0; s < r.length; s++) {\n    var n = r.charAt(s),\n      a = n.charCodeAt(0);\n    if (t[a] !== 255) throw new TypeError(n + \" is ambiguous\");\n    t[a] = s;\n  }\n  var o = r.length,\n    h = r.charAt(0),\n    l = Math.log(o) / Math.log(256),\n    d = Math.log(256) / Math.log(o);\n  function b(u) {\n    if (u instanceof Uint8Array || (ArrayBuffer.isView(u) ? u = new Uint8Array(u.buffer, u.byteOffset, u.byteLength) : Array.isArray(u) && (u = Uint8Array.from(u))), !(u instanceof Uint8Array)) throw new TypeError(\"Expected Uint8Array\");\n    if (u.length === 0) return \"\";\n    for (var D = 0, A = 0, v = 0, R = u.length; v !== R && u[v] === 0;) v++, D++;\n    for (var T = (R - v) * d + 1 >>> 0, m = new Uint8Array(T); v !== R;) {\n      for (var S = u[v], x = 0, I = T - 1; (S !== 0 || x < A) && I !== -1; I--, x++) S += 256 * m[I] >>> 0, m[I] = S % o >>> 0, S = S / o >>> 0;\n      if (S !== 0) throw new Error(\"Non-zero carry\");\n      A = x, v++;\n    }\n    for (var P = T - A; P !== T && m[P] === 0;) P++;\n    for (var B = h.repeat(D); P < T; ++P) B += r.charAt(m[P]);\n    return B;\n  }\n  function y(u) {\n    if (typeof u != \"string\") throw new TypeError(\"Expected String\");\n    if (u.length === 0) return new Uint8Array();\n    var D = 0;\n    if (u[D] !== \" \") {\n      for (var A = 0, v = 0; u[D] === h;) A++, D++;\n      for (var R = (u.length - D) * l + 1 >>> 0, T = new Uint8Array(R); u[D];) {\n        var m = t[u.charCodeAt(D)];\n        if (m === 255) return;\n        for (var S = 0, x = R - 1; (m !== 0 || S < v) && x !== -1; x--, S++) m += o * T[x] >>> 0, T[x] = m % 256 >>> 0, m = m / 256 >>> 0;\n        if (m !== 0) throw new Error(\"Non-zero carry\");\n        v = S, D++;\n      }\n      if (u[D] !== \" \") {\n        for (var I = R - v; I !== R && T[I] === 0;) I++;\n        for (var P = new Uint8Array(A + (R - I)), B = A; I !== R;) P[B++] = T[I++];\n        return P;\n      }\n    }\n  }\n  function k(u) {\n    var D = y(u);\n    if (D) return D;\n    throw new Error(`Non-${e} character`);\n  }\n  return {\n    encode: b,\n    decodeUnsafe: y,\n    decode: k\n  };\n}\nvar Fi = $i,\n  Mi = Fi;\nconst Oe = r => {\n    if (r instanceof Uint8Array && r.constructor.name === \"Uint8Array\") return r;\n    if (r instanceof ArrayBuffer) return new Uint8Array(r);\n    if (ArrayBuffer.isView(r)) return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);\n    throw new Error(\"Unknown type, must be binary type\");\n  },\n  Ki = r => new TextEncoder().encode(r),\n  ki = r => new TextDecoder().decode(r);\nclass Bi {\n  constructor(e, t, i) {\n    this.name = e, this.prefix = t, this.baseEncode = i;\n  }\n  encode(e) {\n    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;\n    throw Error(\"Unknown type, must be binary type\");\n  }\n}\nclass ji {\n  constructor(e, t, i) {\n    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error(\"Invalid prefix character\");\n    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = i;\n  }\n  decode(e) {\n    if (typeof e == \"string\") {\n      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n      return this.baseDecode(e.slice(this.prefix.length));\n    } else throw Error(\"Can only multibase decode strings\");\n  }\n  or(e) {\n    return xe(this, e);\n  }\n}\nclass Vi {\n  constructor(e) {\n    this.decoders = e;\n  }\n  or(e) {\n    return xe(this, e);\n  }\n  decode(e) {\n    const t = e[0],\n      i = this.decoders[t];\n    if (i) return i.decode(e);\n    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n  }\n}\nconst xe = (r, e) => new Vi({\n  ...(r.decoders || {\n    [r.prefix]: r\n  }),\n  ...(e.decoders || {\n    [e.prefix]: e\n  })\n});\nclass qi {\n  constructor(e, t, i, s) {\n    this.name = e, this.prefix = t, this.baseEncode = i, this.baseDecode = s, this.encoder = new Bi(e, t, i), this.decoder = new ji(e, t, s);\n  }\n  encode(e) {\n    return this.encoder.encode(e);\n  }\n  decode(e) {\n    return this.decoder.decode(e);\n  }\n}\nconst H = ({\n    name: r,\n    prefix: e,\n    encode: t,\n    decode: i\n  }) => new qi(r, e, t, i),\n  M = ({\n    prefix: r,\n    name: e,\n    alphabet: t\n  }) => {\n    const {\n      encode: i,\n      decode: s\n    } = Mi(t, e);\n    return H({\n      prefix: r,\n      name: e,\n      encode: i,\n      decode: n => Oe(s(n))\n    });\n  },\n  Yi = (r, e, t, i) => {\n    const s = {};\n    for (let d = 0; d < e.length; ++d) s[e[d]] = d;\n    let n = r.length;\n    for (; r[n - 1] === \"=\";) --n;\n    const a = new Uint8Array(n * t / 8 | 0);\n    let o = 0,\n      h = 0,\n      l = 0;\n    for (let d = 0; d < n; ++d) {\n      const b = s[r[d]];\n      if (b === void 0) throw new SyntaxError(`Non-${i} character`);\n      h = h << t | b, o += t, o >= 8 && (o -= 8, a[l++] = 255 & h >> o);\n    }\n    if (o >= t || 255 & h << 8 - o) throw new SyntaxError(\"Unexpected end of data\");\n    return a;\n  },\n  Gi = (r, e, t) => {\n    const i = e[e.length - 1] === \"=\",\n      s = (1 << t) - 1;\n    let n = \"\",\n      a = 0,\n      o = 0;\n    for (let h = 0; h < r.length; ++h) for (o = o << 8 | r[h], a += 8; a > t;) a -= t, n += e[s & o >> a];\n    if (a && (n += e[s & o << t - a]), i) for (; n.length * t & 7;) n += \"=\";\n    return n;\n  },\n  p = ({\n    name: r,\n    prefix: e,\n    bitsPerChar: t,\n    alphabet: i\n  }) => H({\n    prefix: e,\n    name: r,\n    encode(s) {\n      return Gi(s, i, t);\n    },\n    decode(s) {\n      return Yi(s, i, t, r);\n    }\n  }),\n  Ji = H({\n    prefix: \"\\0\",\n    name: \"identity\",\n    encode: r => ki(r),\n    decode: r => Ki(r)\n  });\nvar Hi = Object.freeze({\n  __proto__: null,\n  identity: Ji\n});\nconst Wi = p({\n  prefix: \"0\",\n  name: \"base2\",\n  alphabet: \"01\",\n  bitsPerChar: 1\n});\nvar Xi = Object.freeze({\n  __proto__: null,\n  base2: Wi\n});\nconst Zi = p({\n  prefix: \"7\",\n  name: \"base8\",\n  alphabet: \"01234567\",\n  bitsPerChar: 3\n});\nvar Qi = Object.freeze({\n  __proto__: null,\n  base8: Zi\n});\nconst es = M({\n  prefix: \"9\",\n  name: \"base10\",\n  alphabet: \"0123456789\"\n});\nvar ts = Object.freeze({\n  __proto__: null,\n  base10: es\n});\nconst is = p({\n    prefix: \"f\",\n    name: \"base16\",\n    alphabet: \"0123456789abcdef\",\n    bitsPerChar: 4\n  }),\n  ss = p({\n    prefix: \"F\",\n    name: \"base16upper\",\n    alphabet: \"0123456789ABCDEF\",\n    bitsPerChar: 4\n  });\nvar rs = Object.freeze({\n  __proto__: null,\n  base16: is,\n  base16upper: ss\n});\nconst ns = p({\n    prefix: \"b\",\n    name: \"base32\",\n    alphabet: \"abcdefghijklmnopqrstuvwxyz234567\",\n    bitsPerChar: 5\n  }),\n  as = p({\n    prefix: \"B\",\n    name: \"base32upper\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\",\n    bitsPerChar: 5\n  }),\n  os = p({\n    prefix: \"c\",\n    name: \"base32pad\",\n    alphabet: \"abcdefghijklmnopqrstuvwxyz234567=\",\n    bitsPerChar: 5\n  }),\n  hs = p({\n    prefix: \"C\",\n    name: \"base32padupper\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=\",\n    bitsPerChar: 5\n  }),\n  cs = p({\n    prefix: \"v\",\n    name: \"base32hex\",\n    alphabet: \"0123456789abcdefghijklmnopqrstuv\",\n    bitsPerChar: 5\n  }),\n  us = p({\n    prefix: \"V\",\n    name: \"base32hexupper\",\n    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV\",\n    bitsPerChar: 5\n  }),\n  ls = p({\n    prefix: \"t\",\n    name: \"base32hexpad\",\n    alphabet: \"0123456789abcdefghijklmnopqrstuv=\",\n    bitsPerChar: 5\n  }),\n  ds = p({\n    prefix: \"T\",\n    name: \"base32hexpadupper\",\n    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV=\",\n    bitsPerChar: 5\n  }),\n  gs = p({\n    prefix: \"h\",\n    name: \"base32z\",\n    alphabet: \"ybndrfg8ejkmcpqxot1uwisza345h769\",\n    bitsPerChar: 5\n  });\nvar ps = Object.freeze({\n  __proto__: null,\n  base32: ns,\n  base32upper: as,\n  base32pad: os,\n  base32padupper: hs,\n  base32hex: cs,\n  base32hexupper: us,\n  base32hexpad: ls,\n  base32hexpadupper: ds,\n  base32z: gs\n});\nconst Ds = M({\n    prefix: \"k\",\n    name: \"base36\",\n    alphabet: \"0123456789abcdefghijklmnopqrstuvwxyz\"\n  }),\n  ys = M({\n    prefix: \"K\",\n    name: \"base36upper\",\n    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  });\nvar bs = Object.freeze({\n  __proto__: null,\n  base36: Ds,\n  base36upper: ys\n});\nconst ms = M({\n    name: \"base58btc\",\n    prefix: \"z\",\n    alphabet: \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n  }),\n  Es = M({\n    name: \"base58flickr\",\n    prefix: \"Z\",\n    alphabet: \"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\"\n  });\nvar fs = Object.freeze({\n  __proto__: null,\n  base58btc: ms,\n  base58flickr: Es\n});\nconst ws = p({\n    prefix: \"m\",\n    name: \"base64\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n    bitsPerChar: 6\n  }),\n  vs = p({\n    prefix: \"M\",\n    name: \"base64pad\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n    bitsPerChar: 6\n  }),\n  Is = p({\n    prefix: \"u\",\n    name: \"base64url\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\",\n    bitsPerChar: 6\n  }),\n  Cs = p({\n    prefix: \"U\",\n    name: \"base64urlpad\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\",\n    bitsPerChar: 6\n  });\nvar _s = Object.freeze({\n  __proto__: null,\n  base64: ws,\n  base64pad: vs,\n  base64url: Is,\n  base64urlpad: Cs\n});\nconst Ae = Array.from(\"\\u{1F680}\\u{1FA90}\\u2604\\u{1F6F0}\\u{1F30C}\\u{1F311}\\u{1F312}\\u{1F313}\\u{1F314}\\u{1F315}\\u{1F316}\\u{1F317}\\u{1F318}\\u{1F30D}\\u{1F30F}\\u{1F30E}\\u{1F409}\\u2600\\u{1F4BB}\\u{1F5A5}\\u{1F4BE}\\u{1F4BF}\\u{1F602}\\u2764\\u{1F60D}\\u{1F923}\\u{1F60A}\\u{1F64F}\\u{1F495}\\u{1F62D}\\u{1F618}\\u{1F44D}\\u{1F605}\\u{1F44F}\\u{1F601}\\u{1F525}\\u{1F970}\\u{1F494}\\u{1F496}\\u{1F499}\\u{1F622}\\u{1F914}\\u{1F606}\\u{1F644}\\u{1F4AA}\\u{1F609}\\u263A\\u{1F44C}\\u{1F917}\\u{1F49C}\\u{1F614}\\u{1F60E}\\u{1F607}\\u{1F339}\\u{1F926}\\u{1F389}\\u{1F49E}\\u270C\\u2728\\u{1F937}\\u{1F631}\\u{1F60C}\\u{1F338}\\u{1F64C}\\u{1F60B}\\u{1F497}\\u{1F49A}\\u{1F60F}\\u{1F49B}\\u{1F642}\\u{1F493}\\u{1F929}\\u{1F604}\\u{1F600}\\u{1F5A4}\\u{1F603}\\u{1F4AF}\\u{1F648}\\u{1F447}\\u{1F3B6}\\u{1F612}\\u{1F92D}\\u2763\\u{1F61C}\\u{1F48B}\\u{1F440}\\u{1F62A}\\u{1F611}\\u{1F4A5}\\u{1F64B}\\u{1F61E}\\u{1F629}\\u{1F621}\\u{1F92A}\\u{1F44A}\\u{1F973}\\u{1F625}\\u{1F924}\\u{1F449}\\u{1F483}\\u{1F633}\\u270B\\u{1F61A}\\u{1F61D}\\u{1F634}\\u{1F31F}\\u{1F62C}\\u{1F643}\\u{1F340}\\u{1F337}\\u{1F63B}\\u{1F613}\\u2B50\\u2705\\u{1F97A}\\u{1F308}\\u{1F608}\\u{1F918}\\u{1F4A6}\\u2714\\u{1F623}\\u{1F3C3}\\u{1F490}\\u2639\\u{1F38A}\\u{1F498}\\u{1F620}\\u261D\\u{1F615}\\u{1F33A}\\u{1F382}\\u{1F33B}\\u{1F610}\\u{1F595}\\u{1F49D}\\u{1F64A}\\u{1F639}\\u{1F5E3}\\u{1F4AB}\\u{1F480}\\u{1F451}\\u{1F3B5}\\u{1F91E}\\u{1F61B}\\u{1F534}\\u{1F624}\\u{1F33C}\\u{1F62B}\\u26BD\\u{1F919}\\u2615\\u{1F3C6}\\u{1F92B}\\u{1F448}\\u{1F62E}\\u{1F646}\\u{1F37B}\\u{1F343}\\u{1F436}\\u{1F481}\\u{1F632}\\u{1F33F}\\u{1F9E1}\\u{1F381}\\u26A1\\u{1F31E}\\u{1F388}\\u274C\\u270A\\u{1F44B}\\u{1F630}\\u{1F928}\\u{1F636}\\u{1F91D}\\u{1F6B6}\\u{1F4B0}\\u{1F353}\\u{1F4A2}\\u{1F91F}\\u{1F641}\\u{1F6A8}\\u{1F4A8}\\u{1F92C}\\u2708\\u{1F380}\\u{1F37A}\\u{1F913}\\u{1F619}\\u{1F49F}\\u{1F331}\\u{1F616}\\u{1F476}\\u{1F974}\\u25B6\\u27A1\\u2753\\u{1F48E}\\u{1F4B8}\\u2B07\\u{1F628}\\u{1F31A}\\u{1F98B}\\u{1F637}\\u{1F57A}\\u26A0\\u{1F645}\\u{1F61F}\\u{1F635}\\u{1F44E}\\u{1F932}\\u{1F920}\\u{1F927}\\u{1F4CC}\\u{1F535}\\u{1F485}\\u{1F9D0}\\u{1F43E}\\u{1F352}\\u{1F617}\\u{1F911}\\u{1F30A}\\u{1F92F}\\u{1F437}\\u260E\\u{1F4A7}\\u{1F62F}\\u{1F486}\\u{1F446}\\u{1F3A4}\\u{1F647}\\u{1F351}\\u2744\\u{1F334}\\u{1F4A3}\\u{1F438}\\u{1F48C}\\u{1F4CD}\\u{1F940}\\u{1F922}\\u{1F445}\\u{1F4A1}\\u{1F4A9}\\u{1F450}\\u{1F4F8}\\u{1F47B}\\u{1F910}\\u{1F92E}\\u{1F3BC}\\u{1F975}\\u{1F6A9}\\u{1F34E}\\u{1F34A}\\u{1F47C}\\u{1F48D}\\u{1F4E3}\\u{1F942}\"),\n  Rs = Ae.reduce((r, e, t) => (r[t] = e, r), []),\n  Ts = Ae.reduce((r, e, t) => (r[e.codePointAt(0)] = t, r), []);\nfunction Ss(r) {\n  return r.reduce((e, t) => (e += Rs[t], e), \"\");\n}\nfunction Ps(r) {\n  const e = [];\n  for (const t of r) {\n    const i = Ts[t.codePointAt(0)];\n    if (i === void 0) throw new Error(`Non-base256emoji character: ${t}`);\n    e.push(i);\n  }\n  return new Uint8Array(e);\n}\nconst Os = H({\n  prefix: \"\\u{1F680}\",\n  name: \"base256emoji\",\n  encode: Ss,\n  decode: Ps\n});\nvar xs = Object.freeze({\n    __proto__: null,\n    base256emoji: Os\n  }),\n  As = Ne,\n  ze = 128,\n  zs = 127,\n  Ns = ~zs,\n  Us = Math.pow(2, 31);\nfunction Ne(r, e, t) {\n  e = e || [], t = t || 0;\n  for (var i = t; r >= Us;) e[t++] = r & 255 | ze, r /= 128;\n  for (; r & Ns;) e[t++] = r & 255 | ze, r >>>= 7;\n  return e[t] = r | 0, Ne.bytes = t - i + 1, e;\n}\nvar Ls = ae,\n  $s = 128,\n  Ue = 127;\nfunction ae(r, i) {\n  var t = 0,\n    i = i || 0,\n    s = 0,\n    n = i,\n    a,\n    o = r.length;\n  do {\n    if (n >= o) throw ae.bytes = 0, new RangeError(\"Could not decode varint\");\n    a = r[n++], t += s < 28 ? (a & Ue) << s : (a & Ue) * Math.pow(2, s), s += 7;\n  } while (a >= $s);\n  return ae.bytes = n - i, t;\n}\nvar Fs = Math.pow(2, 7),\n  Ms = Math.pow(2, 14),\n  Ks = Math.pow(2, 21),\n  ks = Math.pow(2, 28),\n  Bs = Math.pow(2, 35),\n  js = Math.pow(2, 42),\n  Vs = Math.pow(2, 49),\n  qs = Math.pow(2, 56),\n  Ys = Math.pow(2, 63),\n  Gs = function (r) {\n    return r < Fs ? 1 : r < Ms ? 2 : r < Ks ? 3 : r < ks ? 4 : r < Bs ? 5 : r < js ? 6 : r < Vs ? 7 : r < qs ? 8 : r < Ys ? 9 : 10;\n  },\n  Js = {\n    encode: As,\n    decode: Ls,\n    encodingLength: Gs\n  },\n  Le = Js;\nconst $e = (r, e, t = 0) => (Le.encode(r, e, t), e),\n  Fe = r => Le.encodingLength(r),\n  oe = (r, e) => {\n    const t = e.byteLength,\n      i = Fe(r),\n      s = i + Fe(t),\n      n = new Uint8Array(s + t);\n    return $e(r, n, 0), $e(t, n, i), n.set(e, s), new Hs(r, t, e, n);\n  };\nclass Hs {\n  constructor(e, t, i, s) {\n    this.code = e, this.size = t, this.digest = i, this.bytes = s;\n  }\n}\nconst Me = ({\n  name: r,\n  code: e,\n  encode: t\n}) => new Ws(r, e, t);\nclass Ws {\n  constructor(e, t, i) {\n    this.name = e, this.code = t, this.encode = i;\n  }\n  digest(e) {\n    if (e instanceof Uint8Array) {\n      const t = this.encode(e);\n      return t instanceof Uint8Array ? oe(this.code, t) : t.then(i => oe(this.code, i));\n    } else throw Error(\"Unknown type, must be binary type\");\n  }\n}\nconst Ke = r => async e => new Uint8Array(await crypto.subtle.digest(r, e)),\n  Xs = Me({\n    name: \"sha2-256\",\n    code: 18,\n    encode: Ke(\"SHA-256\")\n  }),\n  Zs = Me({\n    name: \"sha2-512\",\n    code: 19,\n    encode: Ke(\"SHA-512\")\n  });\nvar Qs = Object.freeze({\n  __proto__: null,\n  sha256: Xs,\n  sha512: Zs\n});\nconst ke = 0,\n  er = \"identity\",\n  Be = Oe,\n  tr = r => oe(ke, Be(r)),\n  ir = {\n    code: ke,\n    name: er,\n    encode: Be,\n    digest: tr\n  };\nvar sr = Object.freeze({\n  __proto__: null,\n  identity: ir\n});\nnew TextEncoder(), new TextDecoder();\nconst je = {\n  ...Hi,\n  ...Xi,\n  ...Qi,\n  ...ts,\n  ...rs,\n  ...ps,\n  ...bs,\n  ...fs,\n  ..._s,\n  ...xs\n};\n({\n  ...Qs,\n  ...sr\n});\nfunction Ve(r) {\n  return globalThis.Buffer != null ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : r;\n}\nfunction rr(r = 0) {\n  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Ve(globalThis.Buffer.allocUnsafe(r)) : new Uint8Array(r);\n}\nfunction qe(r, e, t, i) {\n  return {\n    name: r,\n    prefix: e,\n    encoder: {\n      name: r,\n      prefix: e,\n      encode: t\n    },\n    decoder: {\n      decode: i\n    }\n  };\n}\nconst Ye = qe(\"utf8\", \"u\", r => \"u\" + new TextDecoder(\"utf8\").decode(r), r => new TextEncoder().encode(r.substring(1))),\n  he = qe(\"ascii\", \"a\", r => {\n    let e = \"a\";\n    for (let t = 0; t < r.length; t++) e += String.fromCharCode(r[t]);\n    return e;\n  }, r => {\n    r = r.substring(1);\n    const e = rr(r.length);\n    for (let t = 0; t < r.length; t++) e[t] = r.charCodeAt(t);\n    return e;\n  }),\n  nr = {\n    utf8: Ye,\n    \"utf-8\": Ye,\n    hex: je.base16,\n    latin1: he,\n    ascii: he,\n    binary: he,\n    ...je\n  };\nfunction ar(r, e = \"utf8\") {\n  const t = nr[e];\n  if (!t) throw new Error(`Unsupported encoding \"${e}\"`);\n  return (e === \"utf8\" || e === \"utf-8\") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Ve(globalThis.Buffer.from(r, \"utf-8\")) : t.decoder.decode(`${t.prefix}${r}`);\n}\nconst ce = exports.CORE_PROTOCOL = \"wc\",\n  Ge = exports.CORE_VERSION = 2,\n  W = exports.CORE_CONTEXT = \"core\",\n  O = exports.CORE_STORAGE_PREFIX = `${ce}@2:${W}:`,\n  Je = exports.CORE_DEFAULT = {\n    name: W,\n    logger: \"error\"\n  },\n  He = exports.CORE_STORAGE_OPTIONS = {\n    database: \":memory:\"\n  },\n  We = exports.CRYPTO_CONTEXT = \"crypto\",\n  ue = exports.CRYPTO_CLIENT_SEED = \"client_ed25519_seed\",\n  Xe = exports.CRYPTO_JWT_TTL = _time.ONE_DAY,\n  Ze = exports.KEYCHAIN_CONTEXT = \"keychain\",\n  Qe = exports.KEYCHAIN_STORAGE_VERSION = \"0.3\",\n  et = exports.MESSAGES_CONTEXT = \"messages\",\n  tt = exports.MESSAGES_STORAGE_VERSION = \"0.3\",\n  it = exports.PUBLISHER_DEFAULT_TTL = _time.SIX_HOURS,\n  st = exports.PUBLISHER_CONTEXT = \"publisher\",\n  rt = exports.RELAYER_DEFAULT_PROTOCOL = \"irn\",\n  nt = exports.RELAYER_DEFAULT_LOGGER = \"error\",\n  le = exports.RELAYER_DEFAULT_RELAY_URL = \"wss://relay.walletconnect.com\",\n  de = exports.RELAYER_FAILOVER_RELAY_URL = \"wss://relay.walletconnect.org\",\n  at = exports.RELAYER_CONTEXT = \"relayer\",\n  g = exports.RELAYER_EVENTS = {\n    message: \"relayer_message\",\n    message_ack: \"relayer_message_ack\",\n    connect: \"relayer_connect\",\n    disconnect: \"relayer_disconnect\",\n    error: \"relayer_error\",\n    connection_stalled: \"relayer_connection_stalled\",\n    transport_closed: \"relayer_transport_closed\",\n    publish: \"relayer_publish\"\n  },\n  ot = exports.RELAYER_SUBSCRIBER_SUFFIX = \"_subscription\",\n  L = exports.RELAYER_PROVIDER_EVENTS = {\n    payload: \"payload\",\n    connect: \"connect\",\n    disconnect: \"disconnect\",\n    error: \"error\"\n  },\n  ht = exports.RELAYER_RECONNECT_TIMEOUT = _time.ONE_SECOND / 2,\n  or = exports.RELAYER_STORAGE_OPTIONS = {\n    database: \":memory:\"\n  },\n  ct = exports.RELAYER_SDK_VERSION = \"2.9.1\",\n  ut = exports.RELAYER_TRANSPORT_CUTOFF = 1e4,\n  lt = exports.STORE_STORAGE_VERSION = \"0.3\",\n  dt = exports.WALLETCONNECT_CLIENT_ID = \"WALLETCONNECT_CLIENT_ID\",\n  C = exports.SUBSCRIBER_EVENTS = {\n    created: \"subscription_created\",\n    deleted: \"subscription_deleted\",\n    expired: \"subscription_expired\",\n    disabled: \"subscription_disabled\",\n    sync: \"subscription_sync\",\n    resubscribed: \"subscription_resubscribed\"\n  },\n  hr = exports.SUBSCRIBER_DEFAULT_TTL = _time.THIRTY_DAYS,\n  gt = exports.SUBSCRIBER_CONTEXT = \"subscription\",\n  pt = exports.SUBSCRIBER_STORAGE_VERSION = \"0.3\",\n  Dt = exports.PENDING_SUB_RESOLUTION_TIMEOUT = _time.FIVE_SECONDS * 1e3,\n  yt = exports.PAIRING_CONTEXT = \"pairing\",\n  bt = exports.PAIRING_STORAGE_VERSION = \"0.3\",\n  cr = exports.PAIRING_DEFAULT_TTL = _time.THIRTY_DAYS,\n  $ = exports.PAIRING_RPC_OPTS = {\n    wc_pairingDelete: {\n      req: {\n        ttl: _time.ONE_DAY,\n        prompt: !1,\n        tag: 1e3\n      },\n      res: {\n        ttl: _time.ONE_DAY,\n        prompt: !1,\n        tag: 1001\n      }\n    },\n    wc_pairingPing: {\n      req: {\n        ttl: _time.THIRTY_SECONDS,\n        prompt: !1,\n        tag: 1002\n      },\n      res: {\n        ttl: _time.THIRTY_SECONDS,\n        prompt: !1,\n        tag: 1003\n      }\n    },\n    unregistered_method: {\n      req: {\n        ttl: _time.ONE_DAY,\n        prompt: !1,\n        tag: 0\n      },\n      res: {\n        ttl: _time.ONE_DAY,\n        prompt: !1,\n        tag: 0\n      }\n    }\n  },\n  _ = exports.HISTORY_EVENTS = {\n    created: \"history_created\",\n    updated: \"history_updated\",\n    deleted: \"history_deleted\",\n    sync: \"history_sync\"\n  },\n  mt = exports.HISTORY_CONTEXT = \"history\",\n  Et = exports.HISTORY_STORAGE_VERSION = \"0.3\",\n  ft = exports.EXPIRER_CONTEXT = \"expirer\",\n  w = exports.EXPIRER_EVENTS = {\n    created: \"expirer_created\",\n    deleted: \"expirer_deleted\",\n    expired: \"expirer_expired\",\n    sync: \"expirer_sync\"\n  },\n  wt = exports.EXPIRER_STORAGE_VERSION = \"0.3\",\n  ur = exports.EXPIRER_DEFAULT_TTL = _time.ONE_DAY,\n  X = exports.VERIFY_CONTEXT = \"verify-api\",\n  ge = exports.VERIFY_SERVER = \"https://verify.walletconnect.com\";\nclass vt {\n  constructor(e, t) {\n    this.core = e, this.logger = t, this.keychain = new Map(), this.name = Ze, this.version = Qe, this.initialized = !1, this.storagePrefix = O, this.init = async () => {\n      if (!this.initialized) {\n        const i = await this.getKeyChain();\n        typeof i < \"u\" && (this.keychain = i), this.initialized = !0;\n      }\n    }, this.has = i => (this.isInitialized(), this.keychain.has(i)), this.set = async (i, s) => {\n      this.isInitialized(), this.keychain.set(i, s), await this.persist();\n    }, this.get = i => {\n      this.isInitialized();\n      const s = this.keychain.get(i);\n      if (typeof s > \"u\") {\n        const {\n          message: n\n        } = (0, _utils.getInternalError)(\"NO_MATCHING_KEY\", `${this.name}: ${i}`);\n        throw new Error(n);\n      }\n      return s;\n    }, this.del = async i => {\n      this.isInitialized(), this.keychain.delete(i), await this.persist();\n    }, this.core = e, this.logger = (0, _logger.generateChildLogger)(t, this.name);\n  }\n  get context() {\n    return (0, _logger.getLoggerContext)(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  async setKeyChain(e) {\n    await this.core.storage.setItem(this.storageKey, (0, _utils.mapToObj)(e));\n  }\n  async getKeyChain() {\n    const e = await this.core.storage.getItem(this.storageKey);\n    return typeof e < \"u\" ? (0, _utils.objToMap)(e) : void 0;\n  }\n  async persist() {\n    await this.setKeyChain(this.keychain);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = (0, _utils.getInternalError)(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nexports.KeyChain = vt;\nclass It {\n  constructor(e, t, i) {\n    this.core = e, this.logger = t, this.name = We, this.initialized = !1, this.init = async () => {\n      this.initialized || (await this.keychain.init(), this.initialized = !0);\n    }, this.hasKeys = s => (this.isInitialized(), this.keychain.has(s)), this.getClientId = async () => {\n      this.isInitialized();\n      const s = await this.getClientSeed(),\n        n = V.generateKeyPair(s);\n      return V.encodeIss(n.publicKey);\n    }, this.generateKeyPair = () => {\n      this.isInitialized();\n      const s = (0, _utils.generateKeyPair)();\n      return this.setPrivateKey(s.publicKey, s.privateKey);\n    }, this.signJWT = async s => {\n      this.isInitialized();\n      const n = await this.getClientSeed(),\n        a = V.generateKeyPair(n),\n        o = (0, _utils.generateRandomBytes32)(),\n        h = Xe;\n      return await V.signJWT(o, s, h, a);\n    }, this.generateSharedKey = (s, n, a) => {\n      this.isInitialized();\n      const o = this.getPrivateKey(s),\n        h = (0, _utils.deriveSymKey)(o, n);\n      return this.setSymKey(h, a);\n    }, this.setSymKey = async (s, n) => {\n      this.isInitialized();\n      const a = n || (0, _utils.hashKey)(s);\n      return await this.keychain.set(a, s), a;\n    }, this.deleteKeyPair = async s => {\n      this.isInitialized(), await this.keychain.del(s);\n    }, this.deleteSymKey = async s => {\n      this.isInitialized(), await this.keychain.del(s);\n    }, this.encode = async (s, n, a) => {\n      this.isInitialized();\n      const o = (0, _utils.validateEncoding)(a),\n        h = (0, _safeJson.safeJsonStringify)(n);\n      if ((0, _utils.isTypeOneEnvelope)(o)) {\n        const y = o.senderPublicKey,\n          k = o.receiverPublicKey;\n        s = await this.generateSharedKey(y, k);\n      }\n      const l = this.getSymKey(s),\n        {\n          type: d,\n          senderPublicKey: b\n        } = o;\n      return (0, _utils.encrypt)({\n        type: d,\n        symKey: l,\n        message: h,\n        senderPublicKey: b\n      });\n    }, this.decode = async (s, n, a) => {\n      this.isInitialized();\n      const o = (0, _utils.validateDecoding)(n, a);\n      if ((0, _utils.isTypeOneEnvelope)(o)) {\n        const h = o.receiverPublicKey,\n          l = o.senderPublicKey;\n        s = await this.generateSharedKey(h, l);\n      }\n      try {\n        const h = this.getSymKey(s),\n          l = (0, _utils.decrypt)({\n            symKey: h,\n            encoded: n\n          });\n        return (0, _safeJson.safeJsonParse)(l);\n      } catch (h) {\n        this.logger.error(`Failed to decode message from topic: '${s}', clientId: '${await this.getClientId()}'`), this.logger.error(h);\n      }\n    }, this.getPayloadType = s => {\n      const n = (0, _utils.deserialize)(s);\n      return (0, _utils.decodeTypeByte)(n.type);\n    }, this.getPayloadSenderPublicKey = s => {\n      const n = (0, _utils.deserialize)(s);\n      return n.senderPublicKey ? (0, _uint8arrays.toString)(n.senderPublicKey, _utils.BASE16) : void 0;\n    }, this.core = e, this.logger = (0, _logger.generateChildLogger)(t, this.name), this.keychain = i || new vt(this.core, this.logger);\n  }\n  get context() {\n    return (0, _logger.getLoggerContext)(this.logger);\n  }\n  async setPrivateKey(e, t) {\n    return await this.keychain.set(e, t), e;\n  }\n  getPrivateKey(e) {\n    return this.keychain.get(e);\n  }\n  async getClientSeed() {\n    let e = \"\";\n    try {\n      e = this.keychain.get(ue);\n    } catch {\n      e = (0, _utils.generateRandomBytes32)(), await this.keychain.set(ue, e);\n    }\n    return ar(e, \"base16\");\n  }\n  getSymKey(e) {\n    return this.keychain.get(e);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = (0, _utils.getInternalError)(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nexports.Crypto = It;\nclass Ct extends _types.IMessageTracker {\n  constructor(e, t) {\n    super(e, t), this.logger = e, this.core = t, this.messages = new Map(), this.name = et, this.version = tt, this.initialized = !1, this.storagePrefix = O, this.init = async () => {\n      if (!this.initialized) {\n        this.logger.trace(\"Initialized\");\n        try {\n          const i = await this.getRelayerMessages();\n          typeof i < \"u\" && (this.messages = i), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({\n            type: \"method\",\n            method: \"restore\",\n            size: this.messages.size\n          });\n        } catch (i) {\n          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i);\n        } finally {\n          this.initialized = !0;\n        }\n      }\n    }, this.set = async (i, s) => {\n      this.isInitialized();\n      const n = (0, _utils.hashMessage)(s);\n      let a = this.messages.get(i);\n      return typeof a > \"u\" && (a = {}), typeof a[n] < \"u\" || (a[n] = s, this.messages.set(i, a), await this.persist()), n;\n    }, this.get = i => {\n      this.isInitialized();\n      let s = this.messages.get(i);\n      return typeof s > \"u\" && (s = {}), s;\n    }, this.has = (i, s) => {\n      this.isInitialized();\n      const n = this.get(i),\n        a = (0, _utils.hashMessage)(s);\n      return typeof n[a] < \"u\";\n    }, this.del = async i => {\n      this.isInitialized(), this.messages.delete(i), await this.persist();\n    }, this.logger = (0, _logger.generateChildLogger)(e, this.name), this.core = t;\n  }\n  get context() {\n    return (0, _logger.getLoggerContext)(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  async setRelayerMessages(e) {\n    await this.core.storage.setItem(this.storageKey, (0, _utils.mapToObj)(e));\n  }\n  async getRelayerMessages() {\n    const e = await this.core.storage.getItem(this.storageKey);\n    return typeof e < \"u\" ? (0, _utils.objToMap)(e) : void 0;\n  }\n  async persist() {\n    await this.setRelayerMessages(this.messages);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = (0, _utils.getInternalError)(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nexports.MessageTracker = Ct;\nclass lr extends _types.IPublisher {\n  constructor(e, t) {\n    super(e, t), this.relayer = e, this.logger = t, this.events = new _events.EventEmitter(), this.name = st, this.queue = new Map(), this.publishTimeout = (0, _time.toMiliseconds)(_time.TEN_SECONDS), this.queueTimeout = (0, _time.toMiliseconds)(_time.FIVE_SECONDS), this.needsTransportRestart = !1, this.publish = async (i, s, n) => {\n      this.logger.debug(\"Publishing Payload\"), this.logger.trace({\n        type: \"method\",\n        method: \"publish\",\n        params: {\n          topic: i,\n          message: s,\n          opts: n\n        }\n      });\n      try {\n        const a = n?.ttl || it,\n          o = (0, _utils.getRelayProtocolName)(n),\n          h = n?.prompt || !1,\n          l = n?.tag || 0,\n          d = n?.id || (0, _jsonrpcUtils.getBigIntRpcId)().toString(),\n          b = {\n            topic: i,\n            message: s,\n            opts: {\n              ttl: a,\n              relay: o,\n              prompt: h,\n              tag: l,\n              id: d\n            }\n          },\n          y = setTimeout(() => this.queue.set(d, b), this.queueTimeout);\n        try {\n          await await (0, _utils.createExpiringPromise)(this.rpcPublish(i, s, a, o, h, l, d), this.publishTimeout), clearTimeout(y), this.relayer.events.emit(g.publish, b);\n        } catch {\n          this.logger.debug(\"Publishing Payload stalled\"), this.needsTransportRestart = !0;\n          return;\n        }\n        this.logger.debug(\"Successfully Published Payload\"), this.logger.trace({\n          type: \"method\",\n          method: \"publish\",\n          params: {\n            topic: i,\n            message: s,\n            opts: n\n          }\n        });\n      } catch (a) {\n        throw this.logger.debug(\"Failed to Publish Payload\"), this.logger.error(a), a;\n      }\n    }, this.on = (i, s) => {\n      this.events.on(i, s);\n    }, this.once = (i, s) => {\n      this.events.once(i, s);\n    }, this.off = (i, s) => {\n      this.events.off(i, s);\n    }, this.removeListener = (i, s) => {\n      this.events.removeListener(i, s);\n    }, this.relayer = e, this.logger = (0, _logger.generateChildLogger)(t, this.name), this.registerEventListeners();\n  }\n  get context() {\n    return (0, _logger.getLoggerContext)(this.logger);\n  }\n  rpcPublish(e, t, i, s, n, a, o) {\n    var h, l, d, b;\n    const y = {\n      method: (0, _utils.getRelayProtocolApi)(s.protocol).publish,\n      params: {\n        topic: e,\n        message: t,\n        ttl: i,\n        prompt: n,\n        tag: a\n      },\n      id: o\n    };\n    return (0, _utils.isUndefined)((h = y.params) == null ? void 0 : h.prompt) && ((l = y.params) == null || delete l.prompt), (0, _utils.isUndefined)((d = y.params) == null ? void 0 : d.tag) && ((b = y.params) == null || delete b.tag), this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({\n      type: \"message\",\n      direction: \"outgoing\",\n      request: y\n    }), this.relayer.request(y);\n  }\n  onPublish(e) {\n    this.queue.delete(e);\n  }\n  checkQueue() {\n    this.queue.forEach(async e => {\n      const {\n        topic: t,\n        message: i,\n        opts: s\n      } = e;\n      await this.publish(t, i, s);\n    });\n  }\n  registerEventListeners() {\n    this.relayer.core.heartbeat.on(_heartbeat.HEARTBEAT_EVENTS.pulse, () => {\n      if (this.needsTransportRestart) {\n        this.needsTransportRestart = !1, this.relayer.events.emit(g.connection_stalled);\n        return;\n      }\n      this.checkQueue();\n    }), this.relayer.on(g.message_ack, e => {\n      this.onPublish(e.id.toString());\n    });\n  }\n}\nclass dr {\n  constructor() {\n    this.map = new Map(), this.set = (e, t) => {\n      const i = this.get(e);\n      this.exists(e, t) || this.map.set(e, [...i, t]);\n    }, this.get = e => this.map.get(e) || [], this.exists = (e, t) => this.get(e).includes(t), this.delete = (e, t) => {\n      if (typeof t > \"u\") {\n        this.map.delete(e);\n        return;\n      }\n      if (!this.map.has(e)) return;\n      const i = this.get(e);\n      if (!this.exists(e, t)) return;\n      const s = i.filter(n => n !== t);\n      if (!s.length) {\n        this.map.delete(e);\n        return;\n      }\n      this.map.set(e, s);\n    }, this.clear = () => {\n      this.map.clear();\n    };\n  }\n  get topics() {\n    return Array.from(this.map.keys());\n  }\n}\nvar gr = Object.defineProperty,\n  pr = Object.defineProperties,\n  Dr = Object.getOwnPropertyDescriptors,\n  _t = Object.getOwnPropertySymbols,\n  yr = Object.prototype.hasOwnProperty,\n  br = Object.prototype.propertyIsEnumerable,\n  Rt = (r, e, t) => e in r ? gr(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  K = (r, e) => {\n    for (var t in e || (e = {})) yr.call(e, t) && Rt(r, t, e[t]);\n    if (_t) for (var t of _t(e)) br.call(e, t) && Rt(r, t, e[t]);\n    return r;\n  },\n  pe = (r, e) => pr(r, Dr(e));\nclass Tt extends _types.ISubscriber {\n  constructor(e, t) {\n    super(e, t), this.relayer = e, this.logger = t, this.subscriptions = new Map(), this.topicMap = new dr(), this.events = new _events.EventEmitter(), this.name = gt, this.version = pt, this.pending = new Map(), this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = \"pending_sub_watch_label\", this.pollingInterval = 20, this.storagePrefix = O, this.subscribeTimeout = 1e4, this.restartInProgress = !1, this.batchSubscribeTopicsLimit = 500, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restart(), this.registerEventListeners(), this.onEnable(), this.clientId = await this.relayer.core.crypto.getClientId());\n    }, this.subscribe = async (i, s) => {\n      await this.restartToComplete(), this.isInitialized(), this.logger.debug(\"Subscribing Topic\"), this.logger.trace({\n        type: \"method\",\n        method: \"subscribe\",\n        params: {\n          topic: i,\n          opts: s\n        }\n      });\n      try {\n        const n = (0, _utils.getRelayProtocolName)(s),\n          a = {\n            topic: i,\n            relay: n\n          };\n        this.pending.set(i, a);\n        const o = await this.rpcSubscribe(i, n);\n        return this.onSubscribe(o, a), this.logger.debug(\"Successfully Subscribed Topic\"), this.logger.trace({\n          type: \"method\",\n          method: \"subscribe\",\n          params: {\n            topic: i,\n            opts: s\n          }\n        }), o;\n      } catch (n) {\n        throw this.logger.debug(\"Failed to Subscribe Topic\"), this.logger.error(n), n;\n      }\n    }, this.unsubscribe = async (i, s) => {\n      await this.restartToComplete(), this.isInitialized(), typeof s?.id < \"u\" ? await this.unsubscribeById(i, s.id, s) : await this.unsubscribeByTopic(i, s);\n    }, this.isSubscribed = async i => this.topics.includes(i) ? !0 : await new Promise((s, n) => {\n      const a = new _time.Watch();\n      a.start(this.pendingSubscriptionWatchLabel);\n      const o = setInterval(() => {\n        !this.pending.has(i) && this.topics.includes(i) && (clearInterval(o), a.stop(this.pendingSubscriptionWatchLabel), s(!0)), a.elapsed(this.pendingSubscriptionWatchLabel) >= Dt && (clearInterval(o), a.stop(this.pendingSubscriptionWatchLabel), n(new Error(\"Subscription resolution timeout\")));\n      }, this.pollingInterval);\n    }).catch(() => !1), this.on = (i, s) => {\n      this.events.on(i, s);\n    }, this.once = (i, s) => {\n      this.events.once(i, s);\n    }, this.off = (i, s) => {\n      this.events.off(i, s);\n    }, this.removeListener = (i, s) => {\n      this.events.removeListener(i, s);\n    }, this.restart = async () => {\n      this.restartInProgress = !0, await this.restore(), await this.reset(), this.restartInProgress = !1;\n    }, this.relayer = e, this.logger = (0, _logger.generateChildLogger)(t, this.name), this.clientId = \"\";\n  }\n  get context() {\n    return (0, _logger.getLoggerContext)(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  get length() {\n    return this.subscriptions.size;\n  }\n  get ids() {\n    return Array.from(this.subscriptions.keys());\n  }\n  get values() {\n    return Array.from(this.subscriptions.values());\n  }\n  get topics() {\n    return this.topicMap.topics;\n  }\n  hasSubscription(e, t) {\n    let i = !1;\n    try {\n      i = this.getSubscription(e).topic === t;\n    } catch {}\n    return i;\n  }\n  onEnable() {\n    this.cached = [], this.initialized = !0;\n  }\n  onDisable() {\n    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();\n  }\n  async unsubscribeByTopic(e, t) {\n    const i = this.topicMap.get(e);\n    await Promise.all(i.map(async s => await this.unsubscribeById(e, s, t)));\n  }\n  async unsubscribeById(e, t, i) {\n    this.logger.debug(\"Unsubscribing Topic\"), this.logger.trace({\n      type: \"method\",\n      method: \"unsubscribe\",\n      params: {\n        topic: e,\n        id: t,\n        opts: i\n      }\n    });\n    try {\n      const s = (0, _utils.getRelayProtocolName)(i);\n      await this.rpcUnsubscribe(e, t, s);\n      const n = (0, _utils.getSdkError)(\"USER_DISCONNECTED\", `${this.name}, ${e}`);\n      await this.onUnsubscribe(e, t, n), this.logger.debug(\"Successfully Unsubscribed Topic\"), this.logger.trace({\n        type: \"method\",\n        method: \"unsubscribe\",\n        params: {\n          topic: e,\n          id: t,\n          opts: i\n        }\n      });\n    } catch (s) {\n      throw this.logger.debug(\"Failed to Unsubscribe Topic\"), this.logger.error(s), s;\n    }\n  }\n  async rpcSubscribe(e, t) {\n    const i = {\n      method: (0, _utils.getRelayProtocolApi)(t.protocol).subscribe,\n      params: {\n        topic: e\n      }\n    };\n    this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({\n      type: \"payload\",\n      direction: \"outgoing\",\n      request: i\n    });\n    try {\n      await await (0, _utils.createExpiringPromise)(this.relayer.request(i), this.subscribeTimeout);\n    } catch {\n      this.logger.debug(\"Outgoing Relay Subscribe Payload stalled\"), this.relayer.events.emit(g.connection_stalled);\n    }\n    return (0, _utils.hashMessage)(e + this.clientId);\n  }\n  async rpcBatchSubscribe(e) {\n    if (!e.length) return;\n    const t = e[0].relay,\n      i = {\n        method: (0, _utils.getRelayProtocolApi)(t.protocol).batchSubscribe,\n        params: {\n          topics: e.map(s => s.topic)\n        }\n      };\n    this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({\n      type: \"payload\",\n      direction: \"outgoing\",\n      request: i\n    });\n    try {\n      return await await (0, _utils.createExpiringPromise)(this.relayer.request(i), this.subscribeTimeout);\n    } catch {\n      this.logger.debug(\"Outgoing Relay Payload stalled\"), this.relayer.events.emit(g.connection_stalled);\n    }\n  }\n  rpcUnsubscribe(e, t, i) {\n    const s = {\n      method: (0, _utils.getRelayProtocolApi)(i.protocol).unsubscribe,\n      params: {\n        topic: e,\n        id: t\n      }\n    };\n    return this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({\n      type: \"payload\",\n      direction: \"outgoing\",\n      request: s\n    }), this.relayer.request(s);\n  }\n  onSubscribe(e, t) {\n    this.setSubscription(e, pe(K({}, t), {\n      id: e\n    })), this.pending.delete(t.topic);\n  }\n  onBatchSubscribe(e) {\n    e.length && e.forEach(t => {\n      this.setSubscription(t.id, K({}, t)), this.pending.delete(t.topic);\n    });\n  }\n  async onUnsubscribe(e, t, i) {\n    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, i), await this.relayer.messages.del(e);\n  }\n  async setRelayerSubscriptions(e) {\n    await this.relayer.core.storage.setItem(this.storageKey, e);\n  }\n  async getRelayerSubscriptions() {\n    return await this.relayer.core.storage.getItem(this.storageKey);\n  }\n  setSubscription(e, t) {\n    this.subscriptions.has(e) || (this.logger.debug(\"Setting subscription\"), this.logger.trace({\n      type: \"method\",\n      method: \"setSubscription\",\n      id: e,\n      subscription: t\n    }), this.addSubscription(e, t));\n  }\n  addSubscription(e, t) {\n    this.subscriptions.set(e, K({}, t)), this.topicMap.set(t.topic, e), this.events.emit(C.created, t);\n  }\n  getSubscription(e) {\n    this.logger.debug(\"Getting subscription\"), this.logger.trace({\n      type: \"method\",\n      method: \"getSubscription\",\n      id: e\n    });\n    const t = this.subscriptions.get(e);\n    if (!t) {\n      const {\n        message: i\n      } = (0, _utils.getInternalError)(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw new Error(i);\n    }\n    return t;\n  }\n  deleteSubscription(e, t) {\n    this.logger.debug(\"Deleting subscription\"), this.logger.trace({\n      type: \"method\",\n      method: \"deleteSubscription\",\n      id: e,\n      reason: t\n    });\n    const i = this.getSubscription(e);\n    this.subscriptions.delete(e), this.topicMap.delete(i.topic, e), this.events.emit(C.deleted, pe(K({}, i), {\n      reason: t\n    }));\n  }\n  async persist() {\n    await this.setRelayerSubscriptions(this.values), this.events.emit(C.sync);\n  }\n  async reset() {\n    if (this.cached.length) {\n      const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);\n      for (let t = 0; t < e; t++) {\n        const i = this.cached.splice(0, this.batchSubscribeTopicsLimit);\n        await this.batchSubscribe(i);\n      }\n    }\n    this.events.emit(C.resubscribed);\n  }\n  async restore() {\n    try {\n      const e = await this.getRelayerSubscriptions();\n      if (typeof e > \"u\" || !e.length) return;\n      if (this.subscriptions.size) {\n        const {\n          message: t\n        } = (0, _utils.getInternalError)(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({\n        type: \"method\",\n        method: \"restore\",\n        subscriptions: this.values\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);\n    }\n  }\n  async batchSubscribe(e) {\n    if (!e.length) return;\n    const t = await this.rpcBatchSubscribe(e);\n    (0, _utils.isValidArray)(t) && this.onBatchSubscribe(t.map((i, s) => pe(K({}, e[s]), {\n      id: i\n    })));\n  }\n  async onConnect() {\n    this.restartInProgress || (await this.restart(), this.onEnable());\n  }\n  onDisconnect() {\n    this.onDisable();\n  }\n  async checkPending() {\n    if (this.relayer.transportExplicitlyClosed) return;\n    const e = [];\n    this.pending.forEach(t => {\n      e.push(t);\n    }), await this.batchSubscribe(e);\n  }\n  registerEventListeners() {\n    this.relayer.core.heartbeat.on(_heartbeat.HEARTBEAT_EVENTS.pulse, async () => {\n      await this.checkPending();\n    }), this.relayer.on(g.connect, async () => {\n      await this.onConnect();\n    }), this.relayer.on(g.disconnect, () => {\n      this.onDisconnect();\n    }), this.events.on(C.created, async e => {\n      const t = C.created;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        data: e\n      }), await this.persist();\n    }), this.events.on(C.deleted, async e => {\n      const t = C.deleted;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        data: e\n      }), await this.persist();\n    });\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = (0, _utils.getInternalError)(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  async restartToComplete() {\n    this.restartInProgress && (await new Promise(e => {\n      const t = setInterval(() => {\n        this.restartInProgress || (clearInterval(t), e());\n      }, this.pollingInterval);\n    }));\n  }\n}\nexports.Subscriber = Tt;\nvar mr = Object.defineProperty,\n  St = Object.getOwnPropertySymbols,\n  Er = Object.prototype.hasOwnProperty,\n  fr = Object.prototype.propertyIsEnumerable,\n  Pt = (r, e, t) => e in r ? mr(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  wr = (r, e) => {\n    for (var t in e || (e = {})) Er.call(e, t) && Pt(r, t, e[t]);\n    if (St) for (var t of St(e)) fr.call(e, t) && Pt(r, t, e[t]);\n    return r;\n  };\nclass Ot extends _types.IRelayer {\n  constructor(e) {\n    super(e), this.protocol = \"wc\", this.version = 2, this.events = new _events.EventEmitter(), this.name = at, this.transportExplicitlyClosed = !1, this.initialized = !1, this.reconnecting = !1, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = [\"socket hang up\", \"socket stalled\"], this.request = async t => {\n      this.logger.debug(\"Publishing Request Payload\");\n      try {\n        return await this.toEstablishConnection(), await this.provider.request(t);\n      } catch (i) {\n        throw this.logger.debug(\"Failed to Publish Request\"), this.logger.error(i), i;\n      }\n    }, this.core = e.core, this.logger = typeof e.logger < \"u\" && typeof e.logger != \"string\" ? (0, _logger.generateChildLogger)(e.logger, this.name) : (0, _logger.pino)((0, _logger.getDefaultLoggerOptions)({\n      level: e.logger || nt\n    })), this.messages = new Ct(this.logger, e.core), this.subscriber = new Tt(this, this.logger), this.publisher = new lr(this, this.logger), this.relayUrl = e?.relayUrl || le, this.projectId = e.projectId, this.provider = {};\n  }\n  async init() {\n    this.logger.trace(\"Initialized\"), await this.createProvider(), await Promise.all([this.messages.init(), this.subscriber.init()]);\n    try {\n      await this.transportOpen();\n    } catch {\n      this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${de}...`), await this.restartTransport(de);\n    }\n    this.registerEventListeners(), this.initialized = !0, setTimeout(async () => {\n      this.subscriber.topics.length === 0 && (this.logger.info(\"No topics subscribed to after init, closing transport\"), await this.transportClose(), this.transportExplicitlyClosed = !1);\n    }, ut);\n  }\n  get context() {\n    return (0, _logger.getLoggerContext)(this.logger);\n  }\n  get connected() {\n    return this.provider.connection.connected;\n  }\n  get connecting() {\n    return this.provider.connection.connecting;\n  }\n  async publish(e, t, i) {\n    this.isInitialized(), await this.publisher.publish(e, t, i), await this.recordMessageEvent({\n      topic: e,\n      message: t,\n      publishedAt: Date.now()\n    });\n  }\n  async subscribe(e, t) {\n    var i;\n    this.isInitialized();\n    let s = ((i = this.subscriber.topicMap.get(e)) == null ? void 0 : i[0]) || \"\";\n    return s || (await Promise.all([new Promise(n => {\n      this.subscriber.once(C.created, a => {\n        a.topic === e && n();\n      });\n    }), new Promise(async n => {\n      s = await this.subscriber.subscribe(e, t), n();\n    })]), s);\n  }\n  async unsubscribe(e, t) {\n    this.isInitialized(), await this.subscriber.unsubscribe(e, t);\n  }\n  on(e, t) {\n    this.events.on(e, t);\n  }\n  once(e, t) {\n    this.events.once(e, t);\n  }\n  off(e, t) {\n    this.events.off(e, t);\n  }\n  removeListener(e, t) {\n    this.events.removeListener(e, t);\n  }\n  async transportClose() {\n    this.transportExplicitlyClosed = !0, this.connected && (await this.provider.disconnect(), this.events.emit(g.transport_closed));\n  }\n  async transportOpen(e) {\n    if (this.transportExplicitlyClosed = !1, !this.reconnecting) {\n      this.relayUrl = e || this.relayUrl, this.reconnecting = !0;\n      try {\n        await Promise.all([new Promise(t => {\n          this.initialized || t(), this.subscriber.once(C.resubscribed, () => {\n            t();\n          });\n        }), await Promise.race([new Promise(async (t, i) => {\n          await (0, _utils.createExpiringPromise)(this.provider.connect(), 1e4, `Socket stalled when trying to connect to ${this.relayUrl}`).catch(s => i(s)).then(() => t()).finally(() => this.removeListener(g.transport_closed, this.rejectTransportOpen));\n        }), new Promise(t => this.once(g.transport_closed, this.rejectTransportOpen))])]);\n      } catch (t) {\n        this.logger.error(t);\n        const i = t;\n        if (!this.isConnectionStalled(i.message)) throw t;\n        this.events.emit(g.transport_closed);\n      } finally {\n        this.reconnecting = !1;\n      }\n    }\n  }\n  async restartTransport(e) {\n    this.transportExplicitlyClosed || this.reconnecting || (this.relayUrl = e || this.relayUrl, this.connected && (await Promise.all([new Promise(t => {\n      this.provider.once(L.disconnect, () => {\n        t();\n      });\n    }), this.transportClose()])), await this.createProvider(), await this.transportOpen());\n  }\n  isConnectionStalled(e) {\n    return this.staleConnectionErrors.some(t => e.includes(t));\n  }\n  rejectTransportOpen() {\n    throw new Error(\"Attempt to connect to relay via `transportOpen` has stalled. Retrying...\");\n  }\n  async createProvider() {\n    const e = await this.core.crypto.signJWT(this.relayUrl);\n    this.provider = new _jsonrpcProvider.JsonRpcProvider(new _jsonrpcWsConnection.default((0, _utils.formatRelayRpcUrl)({\n      sdkVersion: ct,\n      protocol: this.protocol,\n      version: this.version,\n      relayUrl: this.relayUrl,\n      projectId: this.projectId,\n      auth: e,\n      useOnCloseEvent: !0\n    }))), this.registerProviderListeners();\n  }\n  async recordMessageEvent(e) {\n    const {\n      topic: t,\n      message: i\n    } = e;\n    await this.messages.set(t, i);\n  }\n  async shouldIgnoreMessageEvent(e) {\n    const {\n      topic: t,\n      message: i\n    } = e;\n    if (!i || i.length === 0) return this.logger.debug(`Ignoring invalid/empty message: ${i}`), !0;\n    if (!(await this.subscriber.isSubscribed(t))) return this.logger.debug(`Ignoring message for non-subscribed topic ${t}`), !0;\n    const s = this.messages.has(t, i);\n    return s && this.logger.debug(`Ignoring duplicate message: ${i}`), s;\n  }\n  async onProviderPayload(e) {\n    if (this.logger.debug(\"Incoming Relay Payload\"), this.logger.trace({\n      type: \"payload\",\n      direction: \"incoming\",\n      payload: e\n    }), (0, _jsonrpcUtils.isJsonRpcRequest)(e)) {\n      if (!e.method.endsWith(ot)) return;\n      const t = e.params,\n        {\n          topic: i,\n          message: s,\n          publishedAt: n\n        } = t.data,\n        a = {\n          topic: i,\n          message: s,\n          publishedAt: n\n        };\n      this.logger.debug(\"Emitting Relayer Payload\"), this.logger.trace(wr({\n        type: \"event\",\n        event: t.id\n      }, a)), this.events.emit(t.id, a), await this.acknowledgePayload(e), await this.onMessageEvent(a);\n    } else (0, _jsonrpcUtils.isJsonRpcResponse)(e) && this.events.emit(g.message_ack, e);\n  }\n  async onMessageEvent(e) {\n    (await this.shouldIgnoreMessageEvent(e)) || (this.events.emit(g.message, e), await this.recordMessageEvent(e));\n  }\n  async acknowledgePayload(e) {\n    const t = (0, _jsonrpcUtils.formatJsonRpcResult)(e.id, !0);\n    await this.provider.connection.send(t);\n  }\n  registerProviderListeners() {\n    this.provider.on(L.payload, e => this.onProviderPayload(e)), this.provider.on(L.connect, () => {\n      this.events.emit(g.connect);\n    }), this.provider.on(L.disconnect, () => {\n      this.onProviderDisconnect();\n    }), this.provider.on(L.error, e => {\n      this.logger.error(e), this.events.emit(g.error, e);\n    });\n  }\n  registerEventListeners() {\n    this.events.on(g.connection_stalled, async () => {\n      await this.restartTransport();\n    });\n  }\n  onProviderDisconnect() {\n    this.events.emit(g.disconnect), this.attemptToReconnect();\n  }\n  attemptToReconnect() {\n    this.transportExplicitlyClosed || setTimeout(async () => {\n      await this.restartTransport();\n    }, (0, _time.toMiliseconds)(ht));\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = (0, _utils.getInternalError)(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  async toEstablishConnection() {\n    if (!this.connected) {\n      if (this.connecting) return await new Promise(e => {\n        const t = setInterval(() => {\n          this.connected && (clearInterval(t), e());\n        }, this.connectionStatusPollingInterval);\n      });\n      await this.restartTransport();\n    }\n  }\n}\nexports.Relayer = Ot;\nvar vr = Object.defineProperty,\n  xt = Object.getOwnPropertySymbols,\n  Ir = Object.prototype.hasOwnProperty,\n  Cr = Object.prototype.propertyIsEnumerable,\n  At = (r, e, t) => e in r ? vr(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  zt = (r, e) => {\n    for (var t in e || (e = {})) Ir.call(e, t) && At(r, t, e[t]);\n    if (xt) for (var t of xt(e)) Cr.call(e, t) && At(r, t, e[t]);\n    return r;\n  };\nclass Nt extends _types.IStore {\n  constructor(e, t, i, s = O, n = void 0) {\n    super(e, t, i, s), this.core = e, this.logger = t, this.name = i, this.map = new Map(), this.version = lt, this.cached = [], this.initialized = !1, this.storagePrefix = O, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), this.cached.forEach(a => {\n        this.getKey && a !== null && !(0, _utils.isUndefined)(a) ? this.map.set(this.getKey(a), a) : (0, _utils.isProposalStruct)(a) ? this.map.set(a.id, a) : (0, _utils.isSessionStruct)(a) && this.map.set(a.topic, a);\n      }), this.cached = [], this.initialized = !0);\n    }, this.set = async (a, o) => {\n      this.isInitialized(), this.map.has(a) ? await this.update(a, o) : (this.logger.debug(\"Setting value\"), this.logger.trace({\n        type: \"method\",\n        method: \"set\",\n        key: a,\n        value: o\n      }), this.map.set(a, o), await this.persist());\n    }, this.get = a => (this.isInitialized(), this.logger.debug(\"Getting value\"), this.logger.trace({\n      type: \"method\",\n      method: \"get\",\n      key: a\n    }), this.getData(a)), this.getAll = a => (this.isInitialized(), a ? this.values.filter(o => Object.keys(a).every(h => (0, _lodash.default)(o[h], a[h]))) : this.values), this.update = async (a, o) => {\n      this.isInitialized(), this.logger.debug(\"Updating value\"), this.logger.trace({\n        type: \"method\",\n        method: \"update\",\n        key: a,\n        update: o\n      });\n      const h = zt(zt({}, this.getData(a)), o);\n      this.map.set(a, h), await this.persist();\n    }, this.delete = async (a, o) => {\n      this.isInitialized(), this.map.has(a) && (this.logger.debug(\"Deleting value\"), this.logger.trace({\n        type: \"method\",\n        method: \"delete\",\n        key: a,\n        reason: o\n      }), this.map.delete(a), await this.persist());\n    }, this.logger = (0, _logger.generateChildLogger)(t, this.name), this.storagePrefix = s, this.getKey = n;\n  }\n  get context() {\n    return (0, _logger.getLoggerContext)(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  get length() {\n    return this.map.size;\n  }\n  get keys() {\n    return Array.from(this.map.keys());\n  }\n  get values() {\n    return Array.from(this.map.values());\n  }\n  async setDataStore(e) {\n    await this.core.storage.setItem(this.storageKey, e);\n  }\n  async getDataStore() {\n    return await this.core.storage.getItem(this.storageKey);\n  }\n  getData(e) {\n    const t = this.map.get(e);\n    if (!t) {\n      const {\n        message: i\n      } = (0, _utils.getInternalError)(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw this.logger.error(i), new Error(i);\n    }\n    return t;\n  }\n  async persist() {\n    await this.setDataStore(this.values);\n  }\n  async restore() {\n    try {\n      const e = await this.getDataStore();\n      if (typeof e > \"u\" || !e.length) return;\n      if (this.map.size) {\n        const {\n          message: t\n        } = (0, _utils.getInternalError)(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({\n        type: \"method\",\n        method: \"restore\",\n        value: this.values\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);\n    }\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = (0, _utils.getInternalError)(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nexports.Store = Nt;\nclass Ut {\n  constructor(e, t) {\n    this.core = e, this.logger = t, this.name = yt, this.version = bt, this.events = new _events.default(), this.initialized = !1, this.storagePrefix = O, this.ignoredPayloadTypes = [_utils.TYPE_1], this.registeredMethods = [], this.init = async () => {\n      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace(\"Initialized\"));\n    }, this.register = ({\n      methods: i\n    }) => {\n      this.isInitialized(), this.registeredMethods = [...new Set([...this.registeredMethods, ...i])];\n    }, this.create = async () => {\n      this.isInitialized();\n      const i = (0, _utils.generateRandomBytes32)(),\n        s = await this.core.crypto.setSymKey(i),\n        n = (0, _utils.calcExpiry)(_time.FIVE_MINUTES),\n        a = {\n          protocol: rt\n        },\n        o = {\n          topic: s,\n          expiry: n,\n          relay: a,\n          active: !1\n        },\n        h = (0, _utils.formatUri)({\n          protocol: this.core.protocol,\n          version: this.core.version,\n          topic: s,\n          symKey: i,\n          relay: a\n        });\n      return await this.pairings.set(s, o), await this.core.relayer.subscribe(s), this.core.expirer.set(s, n), {\n        topic: s,\n        uri: h\n      };\n    }, this.pair = async i => {\n      this.isInitialized(), this.isValidPair(i);\n      const {\n        topic: s,\n        symKey: n,\n        relay: a\n      } = (0, _utils.parseUri)(i.uri);\n      if (this.pairings.keys.includes(s)) throw new Error(`Pairing already exists: ${s}`);\n      if (this.core.crypto.hasKeys(s)) throw new Error(`Keychain already exists: ${s}`);\n      const o = (0, _utils.calcExpiry)(_time.FIVE_MINUTES),\n        h = {\n          topic: s,\n          relay: a,\n          expiry: o,\n          active: !1\n        };\n      return await this.pairings.set(s, h), await this.core.crypto.setSymKey(n, s), await this.core.relayer.subscribe(s, {\n        relay: a\n      }), this.core.expirer.set(s, o), i.activatePairing && (await this.activate({\n        topic: s\n      })), h;\n    }, this.activate = async ({\n      topic: i\n    }) => {\n      this.isInitialized();\n      const s = (0, _utils.calcExpiry)(_time.THIRTY_DAYS);\n      await this.pairings.update(i, {\n        active: !0,\n        expiry: s\n      }), this.core.expirer.set(i, s);\n    }, this.ping = async i => {\n      this.isInitialized(), await this.isValidPing(i);\n      const {\n        topic: s\n      } = i;\n      if (this.pairings.keys.includes(s)) {\n        const n = await this.sendRequest(s, \"wc_pairingPing\", {}),\n          {\n            done: a,\n            resolve: o,\n            reject: h\n          } = (0, _utils.createDelayedPromise)();\n        this.events.once((0, _utils.engineEvent)(\"pairing_ping\", n), ({\n          error: l\n        }) => {\n          l ? h(l) : o();\n        }), await a();\n      }\n    }, this.updateExpiry = async ({\n      topic: i,\n      expiry: s\n    }) => {\n      this.isInitialized(), await this.pairings.update(i, {\n        expiry: s\n      });\n    }, this.updateMetadata = async ({\n      topic: i,\n      metadata: s\n    }) => {\n      this.isInitialized(), await this.pairings.update(i, {\n        peerMetadata: s\n      });\n    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async i => {\n      this.isInitialized(), await this.isValidDisconnect(i);\n      const {\n        topic: s\n      } = i;\n      this.pairings.keys.includes(s) && (await this.sendRequest(s, \"wc_pairingDelete\", (0, _utils.getSdkError)(\"USER_DISCONNECTED\")), await this.deletePairing(s));\n    }, this.sendRequest = async (i, s, n) => {\n      const a = (0, _jsonrpcUtils.formatJsonRpcRequest)(s, n),\n        o = await this.core.crypto.encode(i, a),\n        h = $[s].req;\n      return this.core.history.set(i, a), this.core.relayer.publish(i, o, h), a.id;\n    }, this.sendResult = async (i, s, n) => {\n      const a = (0, _jsonrpcUtils.formatJsonRpcResult)(i, n),\n        o = await this.core.crypto.encode(s, a),\n        h = await this.core.history.get(s, i),\n        l = $[h.request.method].res;\n      await this.core.relayer.publish(s, o, l), await this.core.history.resolve(a);\n    }, this.sendError = async (i, s, n) => {\n      const a = (0, _jsonrpcUtils.formatJsonRpcError)(i, n),\n        o = await this.core.crypto.encode(s, a),\n        h = await this.core.history.get(s, i),\n        l = $[h.request.method] ? $[h.request.method].res : $.unregistered_method.res;\n      await this.core.relayer.publish(s, o, l), await this.core.history.resolve(a);\n    }, this.deletePairing = async (i, s) => {\n      await this.core.relayer.unsubscribe(i), await Promise.all([this.pairings.delete(i, (0, _utils.getSdkError)(\"USER_DISCONNECTED\")), this.core.crypto.deleteSymKey(i), s ? Promise.resolve() : this.core.expirer.del(i)]);\n    }, this.cleanup = async () => {\n      const i = this.pairings.getAll().filter(s => (0, _utils.isExpired)(s.expiry));\n      await Promise.all(i.map(s => this.deletePairing(s.topic)));\n    }, this.onRelayEventRequest = i => {\n      const {\n        topic: s,\n        payload: n\n      } = i;\n      switch (n.method) {\n        case \"wc_pairingPing\":\n          return this.onPairingPingRequest(s, n);\n        case \"wc_pairingDelete\":\n          return this.onPairingDeleteRequest(s, n);\n        default:\n          return this.onUnknownRpcMethodRequest(s, n);\n      }\n    }, this.onRelayEventResponse = async i => {\n      const {\n          topic: s,\n          payload: n\n        } = i,\n        a = (await this.core.history.get(s, n.id)).request.method;\n      switch (a) {\n        case \"wc_pairingPing\":\n          return this.onPairingPingResponse(s, n);\n        default:\n          return this.onUnknownRpcMethodResponse(a);\n      }\n    }, this.onPairingPingRequest = async (i, s) => {\n      const {\n        id: n\n      } = s;\n      try {\n        this.isValidPing({\n          topic: i\n        }), await this.sendResult(n, i, !0), this.events.emit(\"pairing_ping\", {\n          id: n,\n          topic: i\n        });\n      } catch (a) {\n        await this.sendError(n, i, a), this.logger.error(a);\n      }\n    }, this.onPairingPingResponse = (i, s) => {\n      const {\n        id: n\n      } = s;\n      setTimeout(() => {\n        (0, _jsonrpcUtils.isJsonRpcResult)(s) ? this.events.emit((0, _utils.engineEvent)(\"pairing_ping\", n), {}) : (0, _jsonrpcUtils.isJsonRpcError)(s) && this.events.emit((0, _utils.engineEvent)(\"pairing_ping\", n), {\n          error: s.error\n        });\n      }, 500);\n    }, this.onPairingDeleteRequest = async (i, s) => {\n      const {\n        id: n\n      } = s;\n      try {\n        this.isValidDisconnect({\n          topic: i\n        }), await this.deletePairing(i), this.events.emit(\"pairing_delete\", {\n          id: n,\n          topic: i\n        });\n      } catch (a) {\n        await this.sendError(n, i, a), this.logger.error(a);\n      }\n    }, this.onUnknownRpcMethodRequest = async (i, s) => {\n      const {\n        id: n,\n        method: a\n      } = s;\n      try {\n        if (this.registeredMethods.includes(a)) return;\n        const o = (0, _utils.getSdkError)(\"WC_METHOD_UNSUPPORTED\", a);\n        await this.sendError(n, i, o), this.logger.error(o);\n      } catch (o) {\n        await this.sendError(n, i, o), this.logger.error(o);\n      }\n    }, this.onUnknownRpcMethodResponse = i => {\n      this.registeredMethods.includes(i) || this.logger.error((0, _utils.getSdkError)(\"WC_METHOD_UNSUPPORTED\", i));\n    }, this.isValidPair = i => {\n      if (!(0, _utils.isValidParams)(i)) {\n        const {\n          message: s\n        } = (0, _utils.getInternalError)(\"MISSING_OR_INVALID\", `pair() params: ${i}`);\n        throw new Error(s);\n      }\n      if (!(0, _utils.isValidUrl)(i.uri)) {\n        const {\n          message: s\n        } = (0, _utils.getInternalError)(\"MISSING_OR_INVALID\", `pair() uri: ${i.uri}`);\n        throw new Error(s);\n      }\n    }, this.isValidPing = async i => {\n      if (!(0, _utils.isValidParams)(i)) {\n        const {\n          message: n\n        } = (0, _utils.getInternalError)(\"MISSING_OR_INVALID\", `ping() params: ${i}`);\n        throw new Error(n);\n      }\n      const {\n        topic: s\n      } = i;\n      await this.isValidPairingTopic(s);\n    }, this.isValidDisconnect = async i => {\n      if (!(0, _utils.isValidParams)(i)) {\n        const {\n          message: n\n        } = (0, _utils.getInternalError)(\"MISSING_OR_INVALID\", `disconnect() params: ${i}`);\n        throw new Error(n);\n      }\n      const {\n        topic: s\n      } = i;\n      await this.isValidPairingTopic(s);\n    }, this.isValidPairingTopic = async i => {\n      if (!(0, _utils.isValidString)(i, !1)) {\n        const {\n          message: s\n        } = (0, _utils.getInternalError)(\"MISSING_OR_INVALID\", `pairing topic should be a string: ${i}`);\n        throw new Error(s);\n      }\n      if (!this.pairings.keys.includes(i)) {\n        const {\n          message: s\n        } = (0, _utils.getInternalError)(\"NO_MATCHING_KEY\", `pairing topic doesn't exist: ${i}`);\n        throw new Error(s);\n      }\n      if ((0, _utils.isExpired)(this.pairings.get(i).expiry)) {\n        await this.deletePairing(i);\n        const {\n          message: s\n        } = (0, _utils.getInternalError)(\"EXPIRED\", `pairing topic: ${i}`);\n        throw new Error(s);\n      }\n    }, this.core = e, this.logger = (0, _logger.generateChildLogger)(t, this.name), this.pairings = new Nt(this.core, this.logger, this.name, this.storagePrefix);\n  }\n  get context() {\n    return (0, _logger.getLoggerContext)(this.logger);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = (0, _utils.getInternalError)(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  registerRelayerEvents() {\n    this.core.relayer.on(g.message, async e => {\n      const {\n        topic: t,\n        message: i\n      } = e;\n      if (!this.pairings.keys.includes(t) || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i))) return;\n      const s = await this.core.crypto.decode(t, i);\n      (0, _jsonrpcUtils.isJsonRpcRequest)(s) ? (this.core.history.set(t, s), this.onRelayEventRequest({\n        topic: t,\n        payload: s\n      })) : (0, _jsonrpcUtils.isJsonRpcResponse)(s) && (await this.core.history.resolve(s), await this.onRelayEventResponse({\n        topic: t,\n        payload: s\n      }), this.core.history.delete(t, s.id));\n    });\n  }\n  registerExpirerEvents() {\n    this.core.expirer.on(w.expired, async e => {\n      const {\n        topic: t\n      } = (0, _utils.parseExpirerTarget)(e.target);\n      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, !0), this.events.emit(\"pairing_expire\", {\n        topic: t\n      }));\n    });\n  }\n}\nexports.Pairing = Ut;\nclass Lt extends _types.IJsonRpcHistory {\n  constructor(e, t) {\n    super(e, t), this.core = e, this.logger = t, this.records = new Map(), this.events = new _events.EventEmitter(), this.name = mt, this.version = Et, this.cached = [], this.initialized = !1, this.storagePrefix = O, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), this.cached.forEach(i => this.records.set(i.id, i)), this.cached = [], this.registerEventListeners(), this.initialized = !0);\n    }, this.set = (i, s, n) => {\n      if (this.isInitialized(), this.logger.debug(\"Setting JSON-RPC request history record\"), this.logger.trace({\n        type: \"method\",\n        method: \"set\",\n        topic: i,\n        request: s,\n        chainId: n\n      }), this.records.has(s.id)) return;\n      const a = {\n        id: s.id,\n        topic: i,\n        request: {\n          method: s.method,\n          params: s.params || null\n        },\n        chainId: n,\n        expiry: (0, _utils.calcExpiry)(_time.THIRTY_DAYS)\n      };\n      this.records.set(a.id, a), this.events.emit(_.created, a);\n    }, this.resolve = async i => {\n      if (this.isInitialized(), this.logger.debug(\"Updating JSON-RPC response history record\"), this.logger.trace({\n        type: \"method\",\n        method: \"update\",\n        response: i\n      }), !this.records.has(i.id)) return;\n      const s = await this.getRecord(i.id);\n      typeof s.response > \"u\" && (s.response = (0, _jsonrpcUtils.isJsonRpcError)(i) ? {\n        error: i.error\n      } : {\n        result: i.result\n      }, this.records.set(s.id, s), this.events.emit(_.updated, s));\n    }, this.get = async (i, s) => (this.isInitialized(), this.logger.debug(\"Getting record\"), this.logger.trace({\n      type: \"method\",\n      method: \"get\",\n      topic: i,\n      id: s\n    }), await this.getRecord(s)), this.delete = (i, s) => {\n      this.isInitialized(), this.logger.debug(\"Deleting record\"), this.logger.trace({\n        type: \"method\",\n        method: \"delete\",\n        id: s\n      }), this.values.forEach(n => {\n        if (n.topic === i) {\n          if (typeof s < \"u\" && n.id !== s) return;\n          this.records.delete(n.id), this.events.emit(_.deleted, n);\n        }\n      });\n    }, this.exists = async (i, s) => (this.isInitialized(), this.records.has(s) ? (await this.getRecord(s)).topic === i : !1), this.on = (i, s) => {\n      this.events.on(i, s);\n    }, this.once = (i, s) => {\n      this.events.once(i, s);\n    }, this.off = (i, s) => {\n      this.events.off(i, s);\n    }, this.removeListener = (i, s) => {\n      this.events.removeListener(i, s);\n    }, this.logger = (0, _logger.generateChildLogger)(t, this.name);\n  }\n  get context() {\n    return (0, _logger.getLoggerContext)(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  get size() {\n    return this.records.size;\n  }\n  get keys() {\n    return Array.from(this.records.keys());\n  }\n  get values() {\n    return Array.from(this.records.values());\n  }\n  get pending() {\n    const e = [];\n    return this.values.forEach(t => {\n      if (typeof t.response < \"u\") return;\n      const i = {\n        topic: t.topic,\n        request: (0, _jsonrpcUtils.formatJsonRpcRequest)(t.request.method, t.request.params, t.id),\n        chainId: t.chainId\n      };\n      return e.push(i);\n    }), e;\n  }\n  async setJsonRpcRecords(e) {\n    await this.core.storage.setItem(this.storageKey, e);\n  }\n  async getJsonRpcRecords() {\n    return await this.core.storage.getItem(this.storageKey);\n  }\n  getRecord(e) {\n    this.isInitialized();\n    const t = this.records.get(e);\n    if (!t) {\n      const {\n        message: i\n      } = (0, _utils.getInternalError)(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw new Error(i);\n    }\n    return t;\n  }\n  async persist() {\n    await this.setJsonRpcRecords(this.values), this.events.emit(_.sync);\n  }\n  async restore() {\n    try {\n      const e = await this.getJsonRpcRecords();\n      if (typeof e > \"u\" || !e.length) return;\n      if (this.records.size) {\n        const {\n          message: t\n        } = (0, _utils.getInternalError)(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({\n        type: \"method\",\n        method: \"restore\",\n        records: this.values\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);\n    }\n  }\n  registerEventListeners() {\n    this.events.on(_.created, e => {\n      const t = _.created;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        record: e\n      }), this.persist();\n    }), this.events.on(_.updated, e => {\n      const t = _.updated;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        record: e\n      }), this.persist();\n    }), this.events.on(_.deleted, e => {\n      const t = _.deleted;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        record: e\n      }), this.persist();\n    }), this.core.heartbeat.on(_heartbeat.HEARTBEAT_EVENTS.pulse, () => {\n      this.cleanup();\n    });\n  }\n  cleanup() {\n    try {\n      this.records.forEach(e => {\n        (0, _time.toMiliseconds)(e.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${e.id}`), this.delete(e.topic, e.id));\n      });\n    } catch (e) {\n      this.logger.warn(e);\n    }\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = (0, _utils.getInternalError)(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nexports.JsonRpcHistory = Lt;\nclass $t extends _types.IExpirer {\n  constructor(e, t) {\n    super(e, t), this.core = e, this.logger = t, this.expirations = new Map(), this.events = new _events.EventEmitter(), this.name = ft, this.version = wt, this.cached = [], this.initialized = !1, this.storagePrefix = O, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), this.cached.forEach(i => this.expirations.set(i.target, i)), this.cached = [], this.registerEventListeners(), this.initialized = !0);\n    }, this.has = i => {\n      try {\n        const s = this.formatTarget(i);\n        return typeof this.getExpiration(s) < \"u\";\n      } catch {\n        return !1;\n      }\n    }, this.set = (i, s) => {\n      this.isInitialized();\n      const n = this.formatTarget(i),\n        a = {\n          target: n,\n          expiry: s\n        };\n      this.expirations.set(n, a), this.checkExpiry(n, a), this.events.emit(w.created, {\n        target: n,\n        expiration: a\n      });\n    }, this.get = i => {\n      this.isInitialized();\n      const s = this.formatTarget(i);\n      return this.getExpiration(s);\n    }, this.del = i => {\n      if (this.isInitialized(), this.has(i)) {\n        const s = this.formatTarget(i),\n          n = this.getExpiration(s);\n        this.expirations.delete(s), this.events.emit(w.deleted, {\n          target: s,\n          expiration: n\n        });\n      }\n    }, this.on = (i, s) => {\n      this.events.on(i, s);\n    }, this.once = (i, s) => {\n      this.events.once(i, s);\n    }, this.off = (i, s) => {\n      this.events.off(i, s);\n    }, this.removeListener = (i, s) => {\n      this.events.removeListener(i, s);\n    }, this.logger = (0, _logger.generateChildLogger)(t, this.name);\n  }\n  get context() {\n    return (0, _logger.getLoggerContext)(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  get length() {\n    return this.expirations.size;\n  }\n  get keys() {\n    return Array.from(this.expirations.keys());\n  }\n  get values() {\n    return Array.from(this.expirations.values());\n  }\n  formatTarget(e) {\n    if (typeof e == \"string\") return (0, _utils.formatTopicTarget)(e);\n    if (typeof e == \"number\") return (0, _utils.formatIdTarget)(e);\n    const {\n      message: t\n    } = (0, _utils.getInternalError)(\"UNKNOWN_TYPE\", `Target type: ${typeof e}`);\n    throw new Error(t);\n  }\n  async setExpirations(e) {\n    await this.core.storage.setItem(this.storageKey, e);\n  }\n  async getExpirations() {\n    return await this.core.storage.getItem(this.storageKey);\n  }\n  async persist() {\n    await this.setExpirations(this.values), this.events.emit(w.sync);\n  }\n  async restore() {\n    try {\n      const e = await this.getExpirations();\n      if (typeof e > \"u\" || !e.length) return;\n      if (this.expirations.size) {\n        const {\n          message: t\n        } = (0, _utils.getInternalError)(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({\n        type: \"method\",\n        method: \"restore\",\n        expirations: this.values\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);\n    }\n  }\n  getExpiration(e) {\n    const t = this.expirations.get(e);\n    if (!t) {\n      const {\n        message: i\n      } = (0, _utils.getInternalError)(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw this.logger.error(i), new Error(i);\n    }\n    return t;\n  }\n  checkExpiry(e, t) {\n    const {\n      expiry: i\n    } = t;\n    (0, _time.toMiliseconds)(i) - Date.now() <= 0 && this.expire(e, t);\n  }\n  expire(e, t) {\n    this.expirations.delete(e), this.events.emit(w.expired, {\n      target: e,\n      expiration: t\n    });\n  }\n  checkExpirations() {\n    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));\n  }\n  registerEventListeners() {\n    this.core.heartbeat.on(_heartbeat.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on(w.created, e => {\n      const t = w.created;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        data: e\n      }), this.persist();\n    }), this.events.on(w.expired, e => {\n      const t = w.expired;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        data: e\n      }), this.persist();\n    }), this.events.on(w.deleted, e => {\n      const t = w.deleted;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        data: e\n      }), this.persist();\n    });\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = (0, _utils.getInternalError)(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nexports.Expirer = $t;\nclass Ft extends _types.IVerify {\n  constructor(e, t) {\n    super(e, t), this.projectId = e, this.logger = t, this.name = X, this.initialized = !1, this.init = async i => {\n      (0, _utils.isReactNative)() || !(0, _utils.isBrowser)() || (this.verifyUrl = i?.verifyUrl || ge, await this.createIframe());\n    }, this.register = async i => {\n      var s;\n      if (this.initialized || (await this.init()), !!this.iframe) try {\n        (s = this.iframe.contentWindow) == null || s.postMessage(i.attestationId, this.verifyUrl), this.logger.info(`postMessage sent: ${i.attestationId} ${this.verifyUrl}`);\n      } catch {}\n    }, this.resolve = async i => {\n      var s;\n      if (this.isDevEnv) return \"\";\n      this.logger.info(`resolving attestation: ${i.attestationId}`);\n      const n = this.startAbortTimer(_time.FIVE_SECONDS),\n        a = await fetch(`${this.verifyUrl}/attestation/${i.attestationId}`, {\n          signal: this.abortController.signal\n        });\n      return clearTimeout(n), a.status === 200 ? (s = await a.json()) == null ? void 0 : s.origin : \"\";\n    }, this.createIframe = async () => {\n      try {\n        await Promise.race([new Promise((i, s) => {\n          if (document.getElementById(X)) return i();\n          const n = document.createElement(\"iframe\");\n          n.setAttribute(\"id\", X), n.setAttribute(\"src\", `${this.verifyUrl}/${this.projectId}`), n.style.display = \"none\", n.addEventListener(\"load\", () => {\n            this.initialized = !0, i();\n          }), n.addEventListener(\"error\", a => {\n            s(a);\n          }), document.body.append(n), this.iframe = n;\n        }), new Promise(i => {\n          setTimeout(() => i(\"iframe load timeout\"), (0, _time.toMiliseconds)(_time.ONE_SECOND / 2));\n        })]);\n      } catch (i) {\n        this.logger.error(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.error(i);\n      }\n    }, this.logger = (0, _logger.generateChildLogger)(t, this.name), this.verifyUrl = ge, this.abortController = new AbortController(), this.isDevEnv = (0, _utils.isNode)() && undefined;\n  }\n  get context() {\n    return (0, _logger.getLoggerContext)(this.logger);\n  }\n  startAbortTimer(e) {\n    return setTimeout(() => this.abortController.abort(), (0, _time.toMiliseconds)(e));\n  }\n}\nexports.Verify = Ft;\nvar _r = Object.defineProperty,\n  Mt = Object.getOwnPropertySymbols,\n  Rr = Object.prototype.hasOwnProperty,\n  Tr = Object.prototype.propertyIsEnumerable,\n  Kt = (r, e, t) => e in r ? _r(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  kt = (r, e) => {\n    for (var t in e || (e = {})) Rr.call(e, t) && Kt(r, t, e[t]);\n    if (Mt) for (var t of Mt(e)) Tr.call(e, t) && Kt(r, t, e[t]);\n    return r;\n  };\nclass Z extends _types.ICore {\n  constructor(e) {\n    super(e), this.protocol = ce, this.version = Ge, this.name = W, this.events = new _events.EventEmitter(), this.initialized = !1, this.on = (i, s) => this.events.on(i, s), this.once = (i, s) => this.events.once(i, s), this.off = (i, s) => this.events.off(i, s), this.removeListener = (i, s) => this.events.removeListener(i, s), this.projectId = e?.projectId, this.relayUrl = e?.relayUrl || le;\n    const t = typeof e?.logger < \"u\" && typeof e?.logger != \"string\" ? e.logger : (0, _logger.pino)((0, _logger.getDefaultLoggerOptions)({\n      level: e?.logger || Je.logger\n    }));\n    this.logger = (0, _logger.generateChildLogger)(t, this.name), this.heartbeat = new _heartbeat.HeartBeat(), this.crypto = new It(this, this.logger, e?.keychain), this.history = new Lt(this, this.logger), this.expirer = new $t(this, this.logger), this.storage = e != null && e.storage ? e.storage : new _keyvaluestorage.default(kt(kt({}, He), e?.storageOptions)), this.relayer = new Ot({\n      core: this,\n      logger: this.logger,\n      relayUrl: this.relayUrl,\n      projectId: this.projectId\n    }), this.pairing = new Ut(this, this.logger), this.verify = new Ft(this.projectId || \"\", this.logger);\n  }\n  static async init(e) {\n    const t = new Z(e);\n    await t.initialize();\n    const i = await t.crypto.getClientId();\n    return await t.storage.setItem(dt, i), t;\n  }\n  get context() {\n    return (0, _logger.getLoggerContext)(this.logger);\n  }\n  async start() {\n    this.initialized || (await this.initialize());\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\");\n    try {\n      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = !0, this.logger.info(\"Core Initialization Success\");\n    } catch (e) {\n      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;\n    }\n  }\n}\nexports.default = Z;\nconst Sr = exports.Core = Z;"},"sourceMaps":{"js":{"mappings":[],"sources":{},"lineCount":null}},"error":null,"hash":"b69f25cff35a9b0947119c0c7b5e11e3","cacheData":{"env":{}}}